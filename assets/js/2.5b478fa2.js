(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{272:function(_,a,t){_.exports=t.p+"assets/img/image-20221030112509598.a5ee37dd.png"},273:function(_,a,t){_.exports=t.p+"assets/img/image-20221030114240298.a94818a5.png"},274:function(_,a,t){_.exports=t.p+"assets/img/image-20221030114407558.9bc70720.png"},275:function(_,a,t){_.exports=t.p+"assets/img/image-20221030114927003.d5c9771b.png"},276:function(_,a,t){_.exports=t.p+"assets/img/image-20221030163311867.67e8c564.png"},277:function(_,a,t){_.exports=t.p+"assets/img/image-20221030164305503.84d2763a.png"},278:function(_,a,t){_.exports=t.p+"assets/img/image-20221030164618214.bc42c720.png"},279:function(_,a,t){_.exports=t.p+"assets/img/image-20221030184919026.df6638b9.png"},280:function(_,a,t){_.exports=t.p+"assets/img/image-20221030191334035.1884c3a1.png"},281:function(_,a,t){_.exports=t.p+"assets/img/image-20221030192021395.c23a6aec.png"},282:function(_,a,t){_.exports=t.p+"assets/img/image-20221030201007592.9e8c5e0c.png"},283:function(_,a,t){_.exports=t.p+"assets/img/image-20221030201357910.db752ec7.png"},284:function(_,a,t){_.exports=t.p+"assets/img/image-20221030202940683.d47aa0f5.png"},285:function(_,a,t){_.exports=t.p+"assets/img/image-20221031091429087.04875196.png"},286:function(_,a,t){_.exports=t.p+"assets/img/image-20221031091501823.c57601c0.png"},287:function(_,a,t){_.exports=t.p+"assets/img/image-20221031092527012.a93fa703.png"},288:function(_,a,t){_.exports=t.p+"assets/img/image-20221031093300160.67a260ad.png"},289:function(_,a,t){_.exports=t.p+"assets/img/image-20221031093738934.07de4314.png"},290:function(_,a,t){_.exports=t.p+"assets/img/image-20221031094938348.79d5d4b0.png"},291:function(_,a,t){_.exports=t.p+"assets/img/image-20221031095025917.71c9dde2.png"},292:function(_,a,t){_.exports=t.p+"assets/img/image-20221031095631870.589fc1ea.png"},293:function(_,a,t){_.exports=t.p+"assets/img/image-20221031100721047.ce220037.png"},294:function(_,a,t){_.exports=t.p+"assets/img/image-20221031102027887.fb0cff5b.png"},295:function(_,a,t){_.exports=t.p+"assets/img/image-20221031102327873.9581cdc6.png"},296:function(_,a,t){_.exports=t.p+"assets/img/image-20221031102511010.27417b3b.png"},297:function(_,a,t){_.exports=t.p+"assets/img/image-20221031164939094.3afeb2ed.png"},298:function(_,a,t){_.exports=t.p+"assets/img/image-20221031165025486.96c16d7c.png"},299:function(_,a,t){_.exports=t.p+"assets/img/image-20221031170701813.d10ae6ab.png"},300:function(_,a,t){_.exports=t.p+"assets/img/image-20221031174044568.50bc69e3.png"},301:function(_,a,t){_.exports=t.p+"assets/img/image-20221031193032345.a2d9e961.png"},302:function(_,a,t){_.exports=t.p+"assets/img/image-20221031192754718.e2961410.png"},303:function(_,a,t){_.exports=t.p+"assets/img/image-20221031192929747.81f7fd93.png"},304:function(_,a,t){_.exports=t.p+"assets/img/image-20221031193340739.42b3a279.png"},305:function(_,a,t){_.exports=t.p+"assets/img/image-20221031195146659.68da8679.png"},306:function(_,a,t){_.exports=t.p+"assets/img/image-20221031195256953.c6c99263.png"},307:function(_,a,t){_.exports=t.p+"assets/img/image-20221031201127995.aa62ca2d.png"},308:function(_,a,t){_.exports=t.p+"assets/img/image-20221031202417496.d0fdd7be.png"},309:function(_,a,t){_.exports=t.p+"assets/img/image-20221031202730509.935021da.png"},310:function(_,a,t){_.exports=t.p+"assets/img/image-20221031203139203.d0984e6d.png"},311:function(_,a,t){_.exports=t.p+"assets/img/image-20221101111712854.c6cd82be.png"},312:function(_,a,t){_.exports=t.p+"assets/img/image-20221101111834019.10f81b2d.png"},313:function(_,a,t){_.exports=t.p+"assets/img/image-20221101111859551.f87d15ac.png"},314:function(_,a,t){_.exports=t.p+"assets/img/image-20221102090746058.7ebd8e8a.png"},315:function(_,a,t){_.exports=t.p+"assets/img/image-20221102091650516.77b95dfd.png"},316:function(_,a,t){_.exports=t.p+"assets/img/image-20221102092150308.726f59ec.png"},317:function(_,a,t){_.exports=t.p+"assets/img/image-20221102092242912.e9ec3d67.png"},318:function(_,a,t){_.exports=t.p+"assets/img/image-20221102095610234.e6fb2b49.png"},319:function(_,a,t){_.exports=t.p+"assets/img/image-20221102092616982.90196ae3.png"},320:function(_,a,t){_.exports=t.p+"assets/img/image-20221102092842674.9200d43a.png"},321:function(_,a,t){_.exports=t.p+"assets/img/image-20221102092920450.b36854ee.png"},322:function(_,a,t){_.exports=t.p+"assets/img/image-20221102093258945.d8826278.png"},323:function(_,a,t){_.exports=t.p+"assets/img/image-20221102093340707.50fd0e5b.png"},324:function(_,a,t){_.exports=t.p+"assets/img/image-20221102093612368.b5fb5d2f.png"},325:function(_,a,t){_.exports=t.p+"assets/img/image-20221102093750188.e5fc5b6d.png"},326:function(_,a,t){_.exports=t.p+"assets/img/image-20221102093929988.b5b7b372.png"},327:function(_,a,t){_.exports=t.p+"assets/img/image-20221102111036716.4f60611e.png"},328:function(_,a,t){_.exports=t.p+"assets/img/image-20221102111440035.bc2816ee.png"},329:function(_,a,t){_.exports=t.p+"assets/img/image-20221102175225458.9ecdf7e1.png"},330:function(_,a,t){_.exports=t.p+"assets/img/image-20221102175402749.7721c51d.png"},331:function(_,a,t){_.exports=t.p+"assets/img/image-20221102175619073.92069fec.png"},332:function(_,a,t){_.exports=t.p+"assets/img/image-20221102181311637.c3a69dcb.png"},333:function(_,a,t){_.exports=t.p+"assets/img/image-20221102181213999.ba4f84f4.png"},334:function(_,a,t){_.exports=t.p+"assets/img/image-20221102181604763.3844974d.png"},335:function(_,a,t){_.exports=t.p+"assets/img/image-20221102183517198.84ae385e.png"},336:function(_,a,t){_.exports=t.p+"assets/img/image-20221102184153075.576643d6.png"},337:function(_,a,t){_.exports=t.p+"assets/img/image-20221102184033463.e29e435a.png"},338:function(_,a,t){_.exports=t.p+"assets/img/image-20221102184254885.b3e641f6.png"},339:function(_,a,t){_.exports=t.p+"assets/img/image-20221102195022772.dd2a7199.png"},340:function(_,a,t){_.exports=t.p+"assets/img/image-20221102195354719.f41f50cb.png"},341:function(_,a,t){_.exports=t.p+"assets/img/image-20221102195606238.ad7af59e.png"},342:function(_,a,t){_.exports=t.p+"assets/img/350.8b9d4a20.jpg"},372:function(_,a,t){"use strict";t.r(a);var v=t(14),s=Object(v.a)({},(function(){var _=this,a=_._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"一、操作系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、操作系统"}},[_._v("#")]),_._v(" 一、操作系统")]),_._v(" "),a("h2",{attrs:{id:"_1-操作系统层次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-操作系统层次"}},[_._v("#")]),_._v(" 1. 操作系统层次")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221024155305809.png",alt:"image-20221024155305809"}})]),_._v(" "),a("h2",{attrs:{id:"_2-定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-定义"}},[_._v("#")]),_._v(" 2.定义")]),_._v(" "),a("p",[a("code",[_._v("操作系统")]),_._v("(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供用户和其他软件方便的接口和环境，它是计算机系统中最基本的"),a("code",[_._v("系统软件")])]),_._v(" "),a("h1",{attrs:{id:"二、操作系统功能和目标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、操作系统功能和目标"}},[_._v("#")]),_._v(" 二、操作系统功能和目标")]),_._v(" "),a("h2",{attrs:{id:"_1-系统资源的管理者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-系统资源的管理者"}},[_._v("#")]),_._v(" 1.系统资源的管理者")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221024160818996.png",alt:"image-20221024160818996"}})]),_._v(" "),a("h2",{attrs:{id:"_2-作为硬件和用户之间的接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-作为硬件和用户之间的接口"}},[_._v("#")]),_._v(" 2.作为硬件和用户之间的接口")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221025090622134.png",alt:"image-20221025090622134"}})]),_._v(" "),a("p",[_._v("用户接口：")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221025092059509.png",alt:"image-20221025092059509"}})]),_._v(" "),a("h1",{attrs:{id:"三、操作系统4个特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、操作系统4个特征"}},[_._v("#")]),_._v(" 三、操作系统4个特征")]),_._v(" "),a("p",[_._v("​")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221025093101472.png",alt:"image-20221025093101472"}})]),_._v(" "),a("h2",{attrs:{id:"_1-并发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-并发"}},[_._v("#")]),_._v(" 1.并发")]),_._v(" "),a("p",[a("code",[_._v("并发")]),_._v("：指两个或多个事件在同一时间间隔发生。这些事件"),a("code",[_._v("宏观上是同时发生")]),_._v(",但"),a("code",[_._v("微观上是交替发生的")])]),_._v(" "),a("p",[a("code",[_._v("并行")]),_._v("：指两个或多个事件在同一时刻同时发生")]),_._v(" "),a("h2",{attrs:{id:"_2-共享"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-共享"}},[_._v("#")]),_._v(" 2.共享")]),_._v(" "),a("p",[a("code",[_._v("共享")]),_._v("：即资源共享，是指系统中的资源可供内存中多个并发执行的进程使用共同使用")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221025093849891.png",alt:"image-20221025093849891"}})]),_._v(" "),a("p",[_._v("所谓同时，也是宏观上的，微观上，这些进程可能也是交替进行的")]),_._v(" "),a("h2",{attrs:{id:"并发和共享的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发和共享的关系"}},[_._v("#")]),_._v(" 并发和共享的关系")]),_._v(" "),a("p",[_._v("如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义")]),_._v(" "),a("p",[_._v("如果失去共享性，则QQ和微信等不能同时访问硬盘资源，就无法实现同步发送文件，也就无法并发")]),_._v(" "),a("h2",{attrs:{id:"_3-虚拟"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-虚拟"}},[_._v("#")]),_._v(" 3.虚拟")]),_._v(" "),a("p",[a("code",[_._v("虚拟")]),_._v("是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上市用户感受到的。")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221025095831537.png",alt:"image-20221025095831537"}})]),_._v(" "),a("h2",{attrs:{id:"_4-异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-异步"}},[_._v("#")]),_._v(" 4.异步")]),_._v(" "),a("p",[a("code",[_._v("异步")]),_._v("是指，在多到程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是以某种顺序向前推进")]),_._v(" "),a("h1",{attrs:{id:"四、操作系统的发展与分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、操作系统的发展与分类"}},[_._v("#")]),_._v(" 四、操作系统的发展与分类")]),_._v(" "),a("h2",{attrs:{id:"_1-手工操作阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-手工操作阶段"}},[_._v("#")]),_._v(" 1.手工操作阶段")]),_._v(" "),a("p",[_._v("主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低")]),_._v(" "),a("h2",{attrs:{id:"_2-单道批处理系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-单道批处理系统"}},[_._v("#")]),_._v(" 2.单道批处理系统")]),_._v(" "),a("p",[_._v("引入了"),a("code",[_._v("脱机输入/输出技术")]),_._v("，使用磁带完成。并"),a("code",[_._v("监督程序")]),_._v("负责控制作业的输入、输出")]),_._v(" "),a("p",[_._v("监督程序就是操作系统的雏形")]),_._v(" "),a("p",[_._v("主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。")]),_._v(" "),a("p",[_._v("主要缺点："),a("code",[_._v("内存中仅能有一道程序运行")]),_._v("，只有程序结束之后才能调入下一道程序。"),a("code",[_._v("CPU有大量的时间在空闲等待I/O完成")]),_._v("。资源利用率依然很低")]),_._v(" "),a("h2",{attrs:{id:"_3-多道批处理系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-多道批处理系统"}},[_._v("#")]),_._v(" 3.多道批处理系统")]),_._v(" "),a("p",[_._v("操作系统正式诞生。")]),_._v(" "),a("p",[_._v("主要优点：多道程序"),a("code",[_._v("并发")]),_._v("执行，"),a("code",[_._v("共享")]),_._v("计算机资源。"),a("code",[_._v("资源利用率大幅提升")]),_._v("，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。")]),_._v(" "),a("p",[_._v("主要缺点：用户响应时间长，"),a("code",[_._v("没有人机交互功能")]),_._v("，用户提交之后不能控制自己作业的执行，只能等待计算机处理完成")]),_._v(" "),a("h2",{attrs:{id:"_4-分时操作系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-分时操作系统"}},[_._v("#")]),_._v(" 4.分时操作系统")]),_._v(" "),a("p",[_._v("分时操作系统：计算机以"),a("code",[_._v("时间片")]),_._v("为单位"),a("code",[_._v("轮流为各个用户服务")]),_._v("，各个用户可以通过终端与计算机进行交互。")]),_._v(" "),a("p",[_._v("主要优点：用户请求可以被即是响应，解决人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到其他人的存在")]),_._v(" "),a("p",[_._v("主要缺点："),a("code",[_._v("不能优先处理一些紧急任务")]),_._v("，操作系统对每个用户都是完全公平的，循环地为每个用户服务一个时间片，不区分任务的紧急性")]),_._v(" "),a("h2",{attrs:{id:"_5-实时操作系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-实时操作系统"}},[_._v("#")]),_._v(" 5.实时操作系统")]),_._v(" "),a("p",[_._v("计算机系统接收到信号之后及时进行处理，并且要在规定时间内处理完成事件。实时操作系统的主要特点是"),a("code",[_._v("及时性和可靠性")])]),_._v(" "),a("p",[_._v("主要优点：能够优先响应一些紧急任务，某些紧急任务不需要排队")]),_._v(" "),a("p",[_._v("​\t"),a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221025192855776.png",alt:"image-20221025192855776"}})]),_._v(" "),a("h1",{attrs:{id:"五、os的运行机制和体系结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、os的运行机制和体系结构"}},[_._v("#")]),_._v(" 五、OS的运行机制和体系结构")]),_._v(" "),a("h2",{attrs:{id:"_1-运行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-运行机制"}},[_._v("#")]),_._v(" 1. 运行机制")]),_._v(" "),a("h3",{attrs:{id:"_1-两种指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-两种指令"}},[_._v("#")]),_._v(" （1）两种指令")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("特权指令：高危指令，比如内存清空指令。"),a("code",[_._v("用户程序无法使用")])])]),_._v(" "),a("li",[a("p",[_._v("非特权指令：普通指令。"),a("code",[_._v("用户程序可以使用")])])])]),_._v(" "),a("h3",{attrs:{id:"_2-两种处理器状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-两种处理器状态"}},[_._v("#")]),_._v(" （2）两种处理器状态")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("用户态(目态)：此时CPU只能执行非特权指令")])]),_._v(" "),a("li",[a("p",[_._v("和心态(管态)：特权指令，非特权指令都可以执行")])])]),_._v(" "),a("blockquote",[a("p",[_._v("使用程序状态字寄存器（PSW)中的某标志位来标识当前处理器处于什么状态")])]),_._v(" "),a("h3",{attrs:{id:"_3-两种程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-两种程序"}},[_._v("#")]),_._v(" （3）两种程序")]),_._v(" "),a("ul",[a("li",[_._v("内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态")]),_._v(" "),a("li",[_._v("应用程序：普通应用程序只能执行非特权指令，运行在用户态")])]),_._v(" "),a("h2",{attrs:{id:"_2-操作系统的内核"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-操作系统的内核"}},[_._v("#")]),_._v(" 2.操作系统的内核")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221025194519627.png",alt:"image-20221025194519627"}})]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221025194553756.png",alt:"image-20221025194553756"}})]),_._v(" "),a("h2",{attrs:{id:"_3-操作系统体系结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-操作系统体系结构"}},[_._v("#")]),_._v(" 3.操作系统体系结构")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221025194942189.png",alt:"image-20221025194942189"}})]),_._v(" "),a("h1",{attrs:{id:"六、中断和异常"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、中断和异常"}},[_._v("#")]),_._v(" 六、中断和异常")]),_._v(" "),a("h2",{attrs:{id:"_1-中断的概念和作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-中断的概念和作用"}},[_._v("#")]),_._v(" 1.中断的概念和作用")]),_._v(" "),a("ol",[a("li",[_._v("当中断发生时，CPU立即进入"),a("code",[_._v("核心态")])]),_._v(" "),a("li",[_._v("当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理")]),_._v(" "),a("li",[_._v("对于不同的中断信号，会进行不同的处理")])]),_._v(" "),a("p",[_._v("发生中断，就意味着需要操作系统介入，开始管理工作，由于操作系统的管理工作需要使用特权指令，所以需要CPU"),a("code",[_._v("从用户态转为核心态，使操作系统获得计算机的控制权")]),_._v("，有了中断，才能实现多道程序并发执行")]),_._v(" "),a("p",[a("code",[_._v("用户态到核心态")]),_._v("是通过中断实现的，并且只有中断这一个途径")]),_._v(" "),a("h2",{attrs:{id:"_2-中断的分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-中断的分类"}},[_._v("#")]),_._v(" 2.中断的分类")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026080950359.png",alt:"image-20221026080950359"}})]),_._v(" "),a("h3",{attrs:{id:"外中断处理过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#外中断处理过程"}},[_._v("#")]),_._v(" 外中断处理过程")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026081308106.png",alt:"image-20221026081308106"}})]),_._v(" "),a("h1",{attrs:{id:"七、系统调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、系统调用"}},[_._v("#")]),_._v(" 七、系统调用")]),_._v(" "),a("p",[a("code",[_._v("系统调用")]),_._v("是操作系统提供给应用程序（程序员）使用的接口，可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026083536572.png",alt:"image-20221026083536572"}})]),_._v(" "),a("p",[_._v("0")]),_._v(" "),a("h1",{attrs:{id:"八、进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、进程"}},[_._v("#")]),_._v(" 八、进程")]),_._v(" "),a("p",[a("code",[_._v("程序段、数据段、PCB(进程控制块)")]),_._v("组成了"),a("code",[_._v("进程实体")]),_._v("。创建进程就是创建进程实体中的PCB，撤销进程就是撤销进程实体中的PCB。")]),_._v(" "),a("blockquote",[a("p",[_._v("PCB是进程存在的唯一标志")])]),_._v(" "),a("p",[a("code",[_._v("进程")]),_._v("是进程实体的==运行过程==，是系统进行资源分配和调度的一个独立单位")]),_._v(" "),a("h2",{attrs:{id:"_1-进程的组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程的组成"}},[_._v("#")]),_._v(" 1. 进程的组成")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026101014079.png",alt:"image-20221026101014079"}})]),_._v(" "),a("p",[_._v("​\t"),a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026101206693.png",alt:"image-20221026101206693"}})]),_._v(" "),a("h2",{attrs:{id:"_2-进程的组织"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-进程的组织"}},[_._v("#")]),_._v(" 2. 进程的组织")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026102208884.png",alt:"image-20221026102208884"}})]),_._v(" "),a("h2",{attrs:{id:"_3-进程的特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-进程的特征"}},[_._v("#")]),_._v(" 3.进程的特征")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026102632508.png",alt:"image-20221026102632508"}})]),_._v(" "),a("h1",{attrs:{id:"九、进程的状态与转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、进程的状态与转换"}},[_._v("#")]),_._v(" 九、进程的状态与转换")]),_._v(" "),a("h2",{attrs:{id:"_1-进程的状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程的状态"}},[_._v("#")]),_._v(" 1. 进程的状态")]),_._v(" "),a("p",[_._v("三种基本状态")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026104622917.png",alt:"image-20221026104622917"}})]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026105335263.png",alt:"image-20221026105335263"}})]),_._v(" "),a("h2",{attrs:{id:"_2-进程的转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-进程的转换"}},[_._v("#")]),_._v(" 2.进程的转换")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026105932540.png",alt:"image-20221026105932540"}})]),_._v(" "),a("h1",{attrs:{id:"十、进程控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十、进程控制"}},[_._v("#")]),_._v(" 十、进程控制")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026153713454.png",alt:"image-20221026153713454"}})]),_._v(" "),a("blockquote",[a("p",[_._v("使用"),a("code",[_._v("原语")]),_._v("实现进程控制。原语的特点就是执行期间"),a("code",[_._v("不允许中断")]),_._v("，这种操作即为"),a("code",[_._v("原子操作")])]),_._v(" "),a("p",[_._v("原语采用"),a("code",[_._v("关中断指令")]),_._v("和"),a("code",[_._v("开中断指令")])])]),_._v(" "),a("p",[_._v("原语执行在核心态")]),_._v(" "),a("h2",{attrs:{id:"_1-原语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-原语"}},[_._v("#")]),_._v(" 1.原语")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026154638732.png",alt:"image-20221026154638732"}})]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026154714560.png",alt:"image-20221026154714560"}})]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026155212334.png",alt:"image-20221026155212334"}})]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026155430078.png",alt:"image-20221026155430078"}})]),_._v(" "),a("h1",{attrs:{id:"十一、进程通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十一、进程通信"}},[_._v("#")]),_._v(" 十一、进程通信")]),_._v(" "),a("p",[_._v("进程通信就是指，进程之间的信息交换")]),_._v(" "),a("p",[_._v("为了保证安全："),a("code",[_._v("一个进程不能直接访问另一个进程的地址空间")])]),_._v(" "),a("p",[_._v("但是进程通信又是必须的，操作系统提供了一些方法：")]),_._v(" "),a("ol",[a("li",[_._v("共享存储")]),_._v(" "),a("li",[_._v("消息传递")]),_._v(" "),a("li",[_._v("管道通信")])]),_._v(" "),a("h2",{attrs:{id:"_1-共享存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-共享存储"}},[_._v("#")]),_._v(" 1.共享存储")]),_._v(" "),a("p",[_._v("两个进程对共享空间的访问必须是互斥的")]),_._v(" "),a("p",[a("code",[_._v("基于数据结构的共享")]),_._v("：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢，限制多，是一种低级通信方式")]),_._v(" "),a("p",[a("code",[_._v("基于存储区的共享")]),_._v("：在内存中划分一块共享存储区，数组的形式、存放位置，都是由进程控制，而不是操作系统，相比之下，这种共享方式速度更快，是一种"),a("code",[_._v("高级通信")]),_._v("方式")]),_._v(" "),a("h2",{attrs:{id:"_2-管道通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-管道通信"}},[_._v("#")]),_._v(" 2.管道通信")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026170138966.png",alt:"image-20221026170138966"}})]),_._v(" "),a("ol",[a("li",[_._v("管道只能采用"),a("code",[_._v("半双工通信")]),_._v("，某一时刻只能单向传输，如果想要双向传输，则需要设置两个管道。")]),_._v(" "),a("li",[_._v("各进程要"),a("code",[_._v("互斥")]),_._v("地访问管道")]),_._v(" "),a("li",[_._v("数据以字符流的形式写入管道，当管道写满时，write()写进程将被阻塞。当管道变空时，此读进程read()将被阻塞")]),_._v(" "),a("li",[_._v("如果没写满，就不允许读。如果没读完，就不允许写")]),_._v(" "),a("li",[_._v("数据一旦被读出，就会消失，所以读进程只能有一个。")])]),_._v(" "),a("h2",{attrs:{id:"_3-消息传递"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-消息传递"}},[_._v("#")]),_._v(" 3. 消息传递")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026171254351.png",alt:"image-20221026171254351"}})]),_._v(" "),a("h1",{attrs:{id:"十二、线程-多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十二、线程-多线程"}},[_._v("#")]),_._v(" 十二、线程/多线程")]),_._v(" "),a("h2",{attrs:{id:"_1-什么是线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是线程"}},[_._v("#")]),_._v(" 1. 什么是线程")]),_._v(" "),a("p",[_._v("传统的进程是程序的执行的最小单位，引入了线程之后，线程是最小的单位，一个进程可以有多个线程")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026172128359.png",alt:"image-20221026172128359"}})]),_._v(" "),a("p",[_._v("线程就是"),a("code",[_._v("轻量级")]),_._v("进程。")]),_._v(" "),a("p",[_._v("进程之间可以并发，进程中的线程也可以并发，进一步提高系统的并发度。使得一个进程内可以处理各种任务。")]),_._v(" "),a("p",[_._v("引入线程之后，"),a("code",[_._v("进程")]),_._v("只作为"),a("code",[_._v("除CPU以外的系统资源的分配单元")]),_._v("，如打印机，内存地址，都是分配给进程的")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026172539697.png",alt:"image-20221026172539697"}})]),_._v(" "),a("h2",{attrs:{id:"_2-线程的属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-线程的属性"}},[_._v("#")]),_._v(" 2.线程的属性")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026173415914.png",alt:"image-20221026173415914"}})]),_._v(" "),a("h2",{attrs:{id:"_3-线程的实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-线程的实现方式"}},[_._v("#")]),_._v(" 3.线程的实现方式")]),_._v(" "),a("ol",[a("li",[_._v("用户级线程")])]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026183005921.png",alt:"image-20221026183005921"}})]),_._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[_._v("内核级线程")])]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026183101346.png",alt:"image-20221026183101346"}})]),_._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[_._v("结合使用")])]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026183225489.png",alt:"image-20221026183225489"}})]),_._v(" "),a("h2",{attrs:{id:"_4-多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-多线程"}},[_._v("#")]),_._v(" 4.多线程")]),_._v(" "),a("p",[a("code",[_._v("多对一模型：")])]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026183455107.png",alt:"image-20221026183455107"}})]),_._v(" "),a("p",[a("code",[_._v("一对一模型：")])]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026183603681.png",alt:"image-20221026183603681"}})]),_._v(" "),a("p",[a("code",[_._v("多对多模型：")])]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221026183702219.png",alt:"image-20221026183702219"}})]),_._v(" "),a("h1",{attrs:{id:"十三、处理机调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十三、处理机调度"}},[_._v("#")]),_._v(" 十三、处理机调度")]),_._v(" "),a("h2",{attrs:{id:"_1-调度概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-调度概念"}},[_._v("#")]),_._v(" 1. 调度概念")]),_._v(" "),a("p",[_._v("当有一堆任务要处理时，但由于资源有限，没法同时处理，就需要确定某种"),a("code",[_._v("规则")]),_._v("来"),a("code",[_._v("决定")]),_._v("处理这些任务的顺序，这就是调度所研究的问题")]),_._v(" "),a("h2",{attrs:{id:"_2-三个层次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-三个层次"}},[_._v("#")]),_._v(" 2. 三个层次")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221027103236067.png",alt:"image-20221027103236067"}})]),_._v(" "),a("h2",{attrs:{id:"_3-进程调度时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-进程调度时机"}},[_._v("#")]),_._v(" 3. 进程调度时机")]),_._v(" "),a("p",[a("code",[_._v("进程调度")]),_._v("（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机")]),_._v(" "),a("p",[a("strong",[a("code",[_._v("需要进行")]),_._v("进程调度与切换的情况：")])]),_._v(" "),a("ol",[a("li",[_._v("当前运行的进程"),a("code",[_._v("主动放弃")]),_._v("处理机：\n"),a("ol",[a("li",[_._v("进程正常终止")]),_._v(" "),a("li",[_._v("运行中发生异常")]),_._v(" "),a("li",[_._v("进程主动请求阻塞")])])]),_._v(" "),a("li",[_._v("当前运行的进程"),a("code",[_._v("被动放弃")]),_._v("处理机：\n"),a("ol",[a("li",[_._v("进程的时间片用完")]),_._v(" "),a("li",[_._v("有紧急事件处理")]),_._v(" "),a("li",[_._v("有更高优先级进程进入就绪队列")])])])]),_._v(" "),a("p",[a("strong",[a("code",[_._v("不能进行")]),_._v("进程调度与切换的情况：")])]),_._v(" "),a("ol",[a("li",[_._v("在"),a("code",[_._v("处理中断的过程中")]),_._v("。中断处理复杂，很难做到中断处理过程中进行进程切换")]),_._v(" "),a("li",[_._v("进程在"),a("code",[_._v("操作系统内核程序临界区中")]),_._v("。")]),_._v(" "),a("li",[_._v("在"),a("code",[_._v("原语操作过程中")]),_._v("。原子操作不可中断")])]),_._v(" "),a("blockquote",[a("p",[a("code",[_._v("临界资源：")]),_._v("一个时间段内只允许一个进程使用的资源。各进程需要互斥访问临界资源")]),_._v(" "),a("p",[a("code",[_._v("临界区：")]),_._v("访问临界资源的那一段代码")])]),_._v(" "),a("p",[a("code",[_._v("内核程序临界区")]),_._v("：一般是用来访问"),a("code",[_._v("某种内核数据结构")]),_._v("的，比如进程的就绪队列")]),_._v(" "),a("p",[_._v("当进程要进入就绪队列时，会对就绪队列上锁，等代码执行完成之后，再解锁，此时不能进行调度与切换。此时就绪队列时内核程序临界资源")]),_._v(" "),a("p",[_._v("但是当进程要进入如打印机类的临界资源，也会上锁，但是也可以进行调度和切换。")]),_._v(" "),a("h2",{attrs:{id:"_4-进程调度的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-进程调度的方式"}},[_._v("#")]),_._v(" 4. 进程调度的方式")]),_._v(" "),a("p",[a("strong",[a("code",[_._v("非剥夺调度方式")])])]),_._v(" "),a("p",[_._v("又称"),a("code",[_._v("非抢占方式")]),_._v("，即只允许进程主动放弃处理机。即是有更紧急的进程，也依然会使用处理结果。")]),_._v(" "),a("p",[_._v("实现简单，系统开销小，但无法处理紧急任务")]),_._v(" "),a("p",[a("strong",[a("code",[_._v("剥夺调度方式")])])]),_._v(" "),a("p",[_._v("又称"),a("code",[_._v("抢占方式")]),_._v("，当一个进程正在使用处理机，如果有更紧急的进程，则立即暂停正在执行的进程，将处理机分配给更紧急的进程")]),_._v(" "),a("p",[_._v("可以优先处理更紧急的进程，也可以让进程按照时间片轮流执行。适合于分时操作需提供，实时操作系统")]),_._v(" "),a("h2",{attrs:{id:"_5-进程切换与过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-进程切换与过程"}},[_._v("#")]),_._v(" 5. 进程切换与过程")]),_._v(" "),a("p",[a("code",[_._v("进程调度")]),_._v("：指的就是从就绪队列中选中一个要运行的进程，")]),_._v(" "),a("p",[a("code",[_._v("进程切换")]),_._v("：是指一个进程让出处理机，由另一个进程占用处理机的过程")]),_._v(" "),a("p",[_._v("这个过程主要完成了：")]),_._v(" "),a("ol",[a("li",[_._v("对原来运行进程各种数据的保存")]),_._v(" "),a("li",[_._v("对新的进程各种数据的恢复")])]),_._v(" "),a("h2",{attrs:{id:"_6-调度算法指标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-调度算法指标"}},[_._v("#")]),_._v(" 6. 调度算法指标")]),_._v(" "),a("h3",{attrs:{id:"_1-cpu利用率"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-cpu利用率"}},[_._v("#")]),_._v(" 1. CPU利用率")]),_._v(" "),a("p",[a("code",[_._v("CPU利用率")]),_._v("：指CPU“忙碌”的时间占比总时间比例")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221027110623621.png",alt:"image-20221027110623621"}})]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221027110738925.png",alt:"image-20221027110738925"}})]),_._v(" "),a("h3",{attrs:{id:"_2-系统吞吐量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-系统吞吐量"}},[_._v("#")]),_._v(" 2. 系统吞吐量")]),_._v(" "),a("p",[_._v("单位时间完成作业的数量")]),_._v(" "),a("p",[a("code",[_._v("系统吞吐量=总完成作业/总花费时间")])]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221027110932387.png",alt:"image-20221027110932387"}})]),_._v(" "),a("h3",{attrs:{id:"_3-周转时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-周转时间"}},[_._v("#")]),_._v(" 3. 周转时间")]),_._v(" "),a("p",[_._v("是指从"),a("code",[_._v("作业被提交给系统开始，到作业完成为止")]),_._v("的这段时间间隔")]),_._v(" "),a("p",[a("code",[_._v("周转时间")]),_._v("=作业完成时间 - 作业提交时间")]),_._v(" "),a("p",[a("code",[_._v("平均周转时间=")]),_._v("各作业周转时间之和 / 作业数")]),_._v(" "),a("p",[a("code",[_._v("带权周转时间=")]),_._v("作业周转时间  /  作业实际运行的时间\t= \t作业完成时间 - 作业提交时间 / 作业实际运行时间")]),_._v(" "),a("p",[a("code",[_._v("平均带权周转事件=")]),_._v("各作业带权周转时间之和 / 作业数")]),_._v(" "),a("h3",{attrs:{id:"_4-等待时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-等待时间"}},[_._v("#")]),_._v(" 4.等待时间")]),_._v(" "),a("p",[_._v("是指进程或作业"),a("code",[_._v("处于等待处理机状态时间之和")]),_._v("，等待时间越长，满意度越低")]),_._v(" "),a("h3",{attrs:{id:"_5-响应时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-响应时间"}},[_._v("#")]),_._v(" 5.响应时间")]),_._v(" "),a("p",[_._v("是指用户"),a("code",[_._v("提交请求")]),_._v("到"),a("code",[_._v("首次产生响应")]),_._v("所用的时间")]),_._v(" "),a("h1",{attrs:{id:"十四、调度算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十四、调度算法"}},[_._v("#")]),_._v(" 十四、调度算法")]),_._v(" "),a("p",[_._v("后三种适合于"),a("code",[_._v("交互式系统")])]),_._v(" "),a("h2",{attrs:{id:"_1-fcfs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-fcfs"}},[_._v("#")]),_._v(" 1. FCFS")]),_._v(" "),a("blockquote",[a("p",[a("strong",[_._v("先来先服务FCFS")])])]),_._v(" "),a("p",[a("code",[_._v("算法思想：")]),_._v("主要从公平角度思考，类似排队买东西")]),_._v(" "),a("p",[a("code",[_._v("算法规则：")]),_._v("按照作业/进程到达的先后顺序进行服务")]),_._v(" "),a("p",[a("code",[_._v("用于作业/进程调度")]),_._v("：用于作业调度时：考虑哪个作业先到达后备队列。用于进程调度时：考虑哪个进程先到达就绪队列")]),_._v(" "),a("p",[a("code",[_._v("是否可抢占")]),_._v("：非抢占式算法")]),_._v(" "),a("p",[a("code",[_._v("优缺点：")]),_._v("优点：公平，算法实现简单")]),_._v(" "),a("p",[_._v("​\t\t\t\t\t 缺点：对短作业不利，排在长作业之后，需要等待很长时间")]),_._v(" "),a("p",[a("code",[_._v("是否会导致饥饿：")]),_._v("不会")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221027113930687.png",alt:"image-20221027113930687"}})]),_._v(" "),a("h2",{attrs:{id:"_2-sjf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-sjf"}},[_._v("#")]),_._v(" 2. SJF")]),_._v(" "),a("blockquote",[a("p",[_._v("短作业优先SJF")])]),_._v(" "),a("p",[a("code",[_._v("算法思想：")]),_._v("追求最少的平均等待时间，最少的平均")]),_._v(" "),a("p",[a("code",[_._v("算法规则：")]),_._v("最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）")]),_._v(" "),a("p",[a("code",[_._v("用于作业/进程调度：")]),_._v("两个都可使用，用于进程调度时称为：“短进程优先算法SPF”")]),_._v(" "),a("p",[a("code",[_._v("是否可抢占：")]),_._v("SJF和SPF是"),a("code",[_._v("非抢占式")]),_._v("，但也有抢占版本："),a("code",[_._v("最短剩余时间优先算法SRTN")])]),_._v(" "),a("p",[a("code",[_._v("优缺点")]),_._v("：优点：最短的平均等待时间。缺点：对短作业有利，对长作业不利")]),_._v(" "),a("p",[a("code",[_._v("是否会导致饥饿")]),_._v("：会")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221028095109173.png",alt:"image-20221028095109173"}})]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221028095806460.png",alt:"image-20221028095806460"}})]),_._v(" "),a("h2",{attrs:{id:"_3-hrrn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-hrrn"}},[_._v("#")]),_._v(" 3. HRRN")]),_._v(" "),a("blockquote",[a("p",[a("strong",[_._v("高响应比优先算法")])])]),_._v(" "),a("p",[a("code",[_._v("算法思想：")]),_._v("要综合考虑作业/进程的等待时间和要求服务的时间")]),_._v(" "),a("p",[a("code",[_._v("算法规则：")]),_._v("每次调度之前计算各个作业/进程的"),a("code",[_._v("响应比")]),_._v("。选择响应比最高的作业/进程为其服务")]),_._v(" "),a("p",[_._v("​\t\t\t\t\t    "),a("code",[_._v("响应比=")]),_._v("等待时间+要求服务时间 / 要求服务时间")]),_._v(" "),a("p",[a("code",[_._v("用于作业/进程调度：")]),_._v("都可")]),_._v(" "),a("p",[a("code",[_._v("是否抢占式：")]),_._v("非抢占式")]),_._v(" "),a("p",[a("code",[_._v("优缺点：")]),_._v("综合考虑了等待时间和要求服务时间")]),_._v(" "),a("p",[a("code",[_._v("是否会饥饿：")]),_._v("不会")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221028102950354.png",alt:"image-20221028102950354"}})]),_._v(" "),a("h2",{attrs:{id:"_4-rr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-rr"}},[_._v("#")]),_._v(" 4.RR")]),_._v(" "),a("p",[_._v("以下三种适合"),a("code",[_._v("交互式系统")])]),_._v(" "),a("blockquote",[a("p",[a("strong",[_._v("时间片轮转算法")])])]),_._v(" "),a("p",[a("code",[_._v("算法思想：")]),_._v("公平的，轮流的，为各个进程提供服务，让每个进程在一定时间间隔内都可以得到响应")]),_._v(" "),a("p",[a("code",[_._v("算法规则：")]),_._v("按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，若进程未在一个时间片内完成，则失去处理机，放到队尾重新排队")]),_._v(" "),a("p",[a("code",[_._v("用于作业/进程调度：")]),_._v("进程调度。只有作业放入进程之后，才可能被分配到时间片")]),_._v(" "),a("p",[a("code",[_._v("是否抢占式：")]),_._v("是抢占式。由时钟装置发出时钟中断通知CPU时间片已到")]),_._v(" "),a("p",[a("code",[_._v("优缺点：")]),_._v("公平，响应快，适用于分时操作系统。缺点：开销大，不区分任务的紧急程度")]),_._v(" "),a("p",[a("code",[_._v("是否会饥饿：")]),_._v("不会")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221028104735954.png",alt:"image-20221028104735954"}})]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221028105143140.png",alt:"image-20221028105143140"}})]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221028105106093.png",alt:"image-20221028105106093"}})]),_._v(" "),a("p",[a("code",[_._v("时间片")]),_._v("不能太大，太大就会变为"),a("code",[_._v("先来先服务")]),_._v("算法，会增大进程响应时间")]),_._v(" "),a("h2",{attrs:{id:"_5-优先级调度算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-优先级调度算法"}},[_._v("#")]),_._v(" 5. 优先级调度算法")]),_._v(" "),a("p",[a("code",[_._v("算法思想：")]),_._v("根据任务的紧急程度来决定处理顺序")]),_._v(" "),a("p",[a("code",[_._v("算法规则：")]),_._v("每个作业/进程都有各自的优先级，调度时选择优先级最高的")]),_._v(" "),a("p",[a("code",[_._v("用于作业/进程调度：")]),_._v("都可使用，还可以使用在IO调度中")]),_._v(" "),a("p",[a("code",[_._v("是否抢占式：")]),_._v("抢占式，非抢占式都有。")]),_._v(" "),a("p",[a("code",[_._v("优缺点：")]),_._v("区分紧急程度，重要程度。缺点：如果有很多高优先级进程，则可能导致饥饿")]),_._v(" "),a("p",[a("code",[_._v("是否会饥饿：")]),_._v("会")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221029180129648.png",alt:"image-20221029180129648"}})]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221029181010828.png",alt:"image-20221029181010828"}})]),_._v(" "),a("h2",{attrs:{id:"_6-多级反馈队列调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-多级反馈队列调度"}},[_._v("#")]),_._v(" 6. 多级反馈队列调度")]),_._v(" "),a("p",[a("code",[_._v("算法思想：")]),_._v("对上述其他算法进行折中权衡")]),_._v(" "),a("p",[a("code",[_._v("算法规则：")]),_._v("1.设置多级就绪队列，各级优先队列优先级从高到低，时间片从小到大。2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片")]),_._v(" "),a("p",[a("code",[_._v("用于作业/进程调度：")]),_._v("用于进程调度")]),_._v(" "),a("p",[a("code",[_._v("是否抢占：")]),_._v("抢占式算法。在k级队列中进程运行过程中，若更上级的队列中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。")]),_._v(" "),a("p",[a("code",[_._v("优缺点：")]),_._v("对各类型进程相对公平（FCFS优点）；每个新进程都可以很快得到响应（RR优点）；短进程只用较少的事件即可完成（SJF优点）；可灵活地调整各类进程的偏好程度")]),_._v(" "),a("p",[a("code",[_._v("是否导致饥饿")]),_._v("：会")]),_._v(" "),a("p",[a("img",{attrs:{src:"http://www.erickiku.xyz/typora-images%5Cimage-20221029191652803.png",alt:"image-20221029191652803"}})]),_._v(" "),a("h1",{attrs:{id:"十五、进程同步-互斥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十五、进程同步-互斥"}},[_._v("#")]),_._v(" 十五、进程同步/互斥")]),_._v(" "),a("h2",{attrs:{id:"_1-进程同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程同步"}},[_._v("#")]),_._v(" 1.进程同步")]),_._v(" "),a("p",[_._v("并发具有异步性，有时需要同步处理这些异步问题。")]),_._v(" "),a("p",[_._v("各进程之间推进需要一定的顺序。")]),_._v(" "),a("h2",{attrs:{id:"_2-进程互斥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-进程互斥"}},[_._v("#")]),_._v(" 2.进程互斥")]),_._v(" "),a("p",[_._v("为了实现对临界资源的互斥访问，同时保证系统整体性能，需要以下原则：")]),_._v(" "),a("ol",[a("li",[_._v("空闲让进。临界区空闲时，可以允许一个请求进入临界区的程序立即进入临界区")]),_._v(" "),a("li",[_._v("忙则等待。当已有进程进入临界区，其他试图进入临界区的进程必须等待")]),_._v(" "),a("li",[_._v("有限等待。对请求访问的进程，应保证能在有限时间内进入临界区")]),_._v(" "),a("li",[_._v("让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待")])]),_._v(" "),a("h2",{attrs:{id:"_3-进程互斥的软件实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-进程互斥的软件实现"}},[_._v("#")]),_._v(" 3.进程互斥的软件实现")]),_._v(" "),a("h3",{attrs:{id:"_1-单标签法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-单标签法"}},[_._v("#")]),_._v(" 1. 单标签法")]),_._v(" "),a("p",[a("code",[_._v("算法思想：")]),_._v("两个进程在使用完临界区之后，会把临界区 的使用权限交给另一个进程，也就是每个进程进入临界区的权限只能被另一个进程赋予")]),_._v(" "),a("p",[a("img",{attrs:{src:t(272),alt:"image-20221030112509598"}})]),_._v(" "),a("h3",{attrs:{id:"_2-双标志检查法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-双标志检查法"}},[_._v("#")]),_._v(" 2. 双标志检查法")]),_._v(" "),a("p",[a("img",{attrs:{src:t(273),alt:"image-20221030114240298"}})]),_._v(" "),a("h3",{attrs:{id:"_3-双标志后检查法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-双标志后检查法"}},[_._v("#")]),_._v(" 3.双标志后检查法")]),_._v(" "),a("p",[a("img",{attrs:{src:t(274),alt:"image-20221030114407558"}})]),_._v(" "),a("h3",{attrs:{id:"_4-peterson算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-peterson算法"}},[_._v("#")]),_._v(" 4.Peterson算法")]),_._v(" "),a("p",[a("img",{attrs:{src:t(275),alt:"image-20221030114927003"}})]),_._v(" "),a("p",[_._v("Peterson算法用软件解决了进程互斥问题，遵循了"),a("code",[_._v("空闲让进，忙则等待，有限等待 三个原则。")]),_._v("但是没有遵循"),a("code",[_._v("让权等待")])]),_._v(" "),a("h2",{attrs:{id:"_4-进程互斥的硬件实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-进程互斥的硬件实现"}},[_._v("#")]),_._v(" 4.进程互斥的硬件实现")]),_._v(" "),a("h3",{attrs:{id:"_1-中断屏蔽方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-中断屏蔽方法"}},[_._v("#")]),_._v(" 1. 中断屏蔽方法")]),_._v(" "),a("p",[a("img",{attrs:{src:t(276),alt:"image-20221030163311867"}})]),_._v(" "),a("h3",{attrs:{id:"_2-testandset指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-testandset指令"}},[_._v("#")]),_._v(" 2.TestAndSet指令")]),_._v(" "),a("p",[a("img",{attrs:{src:t(277),alt:"image-20221030164305503"}})]),_._v(" "),a("h3",{attrs:{id:"_3-swap指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-swap指令"}},[_._v("#")]),_._v(" 3.Swap指令")]),_._v(" "),a("p",[a("img",{attrs:{src:t(278),alt:"image-20221030164618214"}})]),_._v(" "),a("h1",{attrs:{id:"十六、信号量机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十六、信号量机制"}},[_._v("#")]),_._v(" 十六、信号量机制")]),_._v(" "),a("p",[_._v("用户进程可以通过使用操作系统提供的"),a("code",[_._v("一对原语")]),_._v("来对"),a("code",[_._v("信号量")]),_._v("进行操作，从而很方便的实现了进程互斥、进程同步")]),_._v(" "),a("p",[a("code",[_._v("信号量")]),_._v("其实就是一个变量，可以用"),a("code",[_._v("一个信号量表示系统中某种资源的数量")])]),_._v(" "),a("p",[a("code",[_._v("一对原语：wait(S)")]),_._v("原语和"),a("code",[_._v("signal(S)")]),_._v("原语，可以把原语理解为自己写的函数，函数名为wait和signal，括号里的"),a("code",[_._v("信号量S")]),_._v("其实就是函数调用时传入的一个参数。")]),_._v(" "),a("p",[a("code",[_._v("wait、signal")]),_._v("原语常简称为"),a("code",[_._v("P、V操作")]),_._v("。因此，做题时常把wait(S和signal(S)两个操作写为"),a("code",[_._v("P(S)、V(S)")])]),_._v(" "),a("h2",{attrs:{id:"_1-整形信号量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-整形信号量"}},[_._v("#")]),_._v(" 1. 整形信号量")]),_._v(" "),a("p",[a("img",{attrs:{src:t(279),alt:"image-20221030184919026"}})]),_._v(" "),a("h2",{attrs:{id:"_2-记录型信号量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-记录型信号量"}},[_._v("#")]),_._v(" 2. 记录型信号量")]),_._v(" "),a("p",[a("img",{attrs:{src:t(280),alt:"image-20221030191334035"}})]),_._v(" "),a("h2",{attrs:{id:"_3-信号量机制实现进程互斥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-信号量机制实现进程互斥"}},[_._v("#")]),_._v(" 3. 信号量机制实现进程互斥")]),_._v(" "),a("p",[a("img",{attrs:{src:t(281),alt:"image-20221030192021395"}})]),_._v(" "),a("h2",{attrs:{id:"_4-信号量机制实现进程同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-信号量机制实现进程同步"}},[_._v("#")]),_._v(" 4. 信号量机制实现进程同步")]),_._v(" "),a("p",[a("img",{attrs:{src:t(282),alt:"image-20221030201007592"}})]),_._v(" "),a("h2",{attrs:{id:"_5-实现进程的同步关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-实现进程的同步关系"}},[_._v("#")]),_._v(" 5.实现进程的同步关系")]),_._v(" "),a("p",[a("img",{attrs:{src:t(283),alt:"image-20221030201357910"}})]),_._v(" "),a("h1",{attrs:{id:"十七、生产者消费者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十七、生产者消费者"}},[_._v("#")]),_._v(" 十七、生产者消费者")]),_._v(" "),a("p",[_._v("系统中有一组生产者进程和消费者进程，生产者进程每次生产一个数据放入缓存区，消费者进程每次从缓冲区中取出一个数据并使用")]),_._v(" "),a("p",[_._v("生产者、消费者共享一个初始为空、大小为n的缓冲区")]),_._v(" "),a("p",[_._v("只有缓冲区没满时，生产者才能把数据放入缓冲区，否则必须等待。只有缓冲区不空时，消费者才能从中取出产品，否则必须等待")]),_._v(" "),a("p",[_._v("缓冲区是"),a("code",[_._v("临界资源")]),_._v("，各进程必须互斥的访问")]),_._v(" "),a("p",[a("img",{attrs:{src:t(284),alt:"image-20221030202940683"}})]),_._v(" "),a("h2",{attrs:{id:"_1-多生产者多消费者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-多生产者多消费者"}},[_._v("#")]),_._v(" 1. 多生产者多消费者")]),_._v(" "),a("p",[a("img",{attrs:{src:t(285),alt:"image-20221031091429087"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(286),alt:"image-20221031091501823"}})]),_._v(" "),a("p",[_._v("如果缓冲区大小大于1，就必须专门放置一个互斥信号量mutex来保证互斥访问缓冲区")]),_._v(" "),a("h1",{attrs:{id:"十八、吸烟者问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十八、吸烟者问题"}},[_._v("#")]),_._v(" 十八、吸烟者问题")]),_._v(" "),a("p",[a("img",{attrs:{src:t(287),alt:"image-20221031092527012"}})]),_._v(" "),a("p",[_._v("如何实现进程同步和进程互斥")]),_._v(" "),a("p",[a("img",{attrs:{src:t(288),alt:"image-20221031093300160"}})]),_._v(" "),a("h1",{attrs:{id:"十九、读者、写者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十九、读者、写者"}},[_._v("#")]),_._v(" 十九、读者、写者")]),_._v(" "),a("p",[a("img",{attrs:{src:t(289),alt:"image-20221031093738934"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(290),alt:"image-20221031094938348"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(291),alt:"image-20221031095025917"}})]),_._v(" "),a("h1",{attrs:{id:"二十、哲学家进餐问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二十、哲学家进餐问题"}},[_._v("#")]),_._v(" 二十、哲学家进餐问题")]),_._v(" "),a("p",[a("img",{attrs:{src:t(292),alt:"image-20221031095631870"}})]),_._v(" "),a("p",[_._v("==这个方法不可取==")]),_._v(" "),a("p",[_._v("解决进程死锁")]),_._v(" "),a("p",[a("img",{attrs:{src:t(293),alt:"image-20221031100721047"}})]),_._v(" "),a("h1",{attrs:{id:"二十一、管程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二十一、管程"}},[_._v("#")]),_._v(" 二十一、管程")]),_._v(" "),a("p",[_._v("为了解决PV操作的复杂，使用管程来简化这些操作")]),_._v(" "),a("h2",{attrs:{id:"_1-管程解决生产者消费者问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-管程解决生产者消费者问题"}},[_._v("#")]),_._v(" 1.管程解决生产者消费者问题")]),_._v(" "),a("p",[a("img",{attrs:{src:t(294),alt:"image-20221031102027887"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(295),alt:"image-20221031102327873"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(296),alt:"image-20221031102511010"}})]),_._v(" "),a("h1",{attrs:{id:"二十二、死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二十二、死锁"}},[_._v("#")]),_._v(" 二十二、死锁")]),_._v(" "),a("h2",{attrs:{id:"_1-死锁、饥饿、死循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-死锁、饥饿、死循环"}},[_._v("#")]),_._v(" 1.死锁、饥饿、死循环")]),_._v(" "),a("p",[a("code",[_._v("死锁：")]),_._v("各进程互相等待对方手里的资源，导致各进程互相阻塞，无法向前推进的现象")]),_._v(" "),a("p",[a("code",[_._v("饥饿：")]),_._v("长期得不到想要的资源，某进程无法向前推进的现象，。")]),_._v(" "),a("p",[a("code",[_._v("死循环：")]),_._v("跳不出某个循环，有时是bug导致，有时是故意设置")]),_._v(" "),a("h2",{attrs:{id:"_2-死锁发生的条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-死锁发生的条件"}},[_._v("#")]),_._v(" 2.死锁发生的条件")]),_._v(" "),a("p",[_._v("必须满足以下四个条件：")]),_._v(" "),a("p",[a("code",[_._v("互斥条件：")]),_._v("只有对必须互斥使用的资源的争抢才会导致死锁")]),_._v(" "),a("p",[a("code",[_._v("不剥夺条件：")]),_._v("进程所获得的资源在未使用完之前，不能 由其他进程夺走资源，只能主动释放")]),_._v(" "),a("p",[a("code",[_._v("请求和保持条件：")]),_._v("进程已经保持了一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又不释放自己的资源")]),_._v(" "),a("p",[a("code",[_._v("循环等待条件：")]),_._v("链中的每一个进程已获得的资源同时被下一个进程所请求")]),_._v(" "),a("p",[a("code",[_._v("注意：")]),_._v("发生死锁时一定有循环等待，但是发生循环等待时未必死锁")]),_._v(" "),a("h2",{attrs:{id:"_3-死锁的处理策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-死锁的处理策略"}},[_._v("#")]),_._v(" 3.死锁的处理策略")]),_._v(" "),a("ol",[a("li",[_._v("预防死锁。破坏死锁产生的四个必要条件中的一个")]),_._v(" "),a("li",[_._v("避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）")]),_._v(" "),a("li",[_._v("死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁")])]),_._v(" "),a("h2",{attrs:{id:"_4-预防死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-预防死锁"}},[_._v("#")]),_._v(" 4.预防死锁")]),_._v(" "),a("h3",{attrs:{id:"_1-破坏互斥条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-破坏互斥条件"}},[_._v("#")]),_._v(" 1.破坏互斥条件")]),_._v(" "),a("p",[_._v("把互斥的资源改为允许共享使用的资源。如"),a("code",[_._v("SPOOLing技术")])]),_._v(" "),a("p",[_._v("缺点：不是所有的资源都可以改造成可共享使用的资源")]),_._v(" "),a("h3",{attrs:{id:"_2-破坏不剥夺条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-破坏不剥夺条件"}},[_._v("#")]),_._v(" 2.破坏不剥夺条件")]),_._v(" "),a("ol",[a("li",[_._v("当某个进程请求新的资源得不到时，必须立刻释放已拥有的资源，等待再重新申请。也就是说，即是某些资源尚未使用完，也要主动释放。")]),_._v(" "),a("li",[_._v("当某个进程需要的资源被其他进程占用时，可以由操作系统协助，将想要的资源强行剥夺。")])]),_._v(" "),a("p",[_._v("缺点：实现复杂。释放资源可能导致前一段工作失效")]),_._v(" "),a("h3",{attrs:{id:"_3-破坏请求和保持条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-破坏请求和保持条件"}},[_._v("#")]),_._v(" 3.破坏请求和保持条件")]),_._v(" "),a("p",[_._v("可以采用静态分配方法，即进程在运行前，申请完它所需要的全部资源，在资源未完成之前，不让进程运行")]),_._v(" "),a("p",[_._v("缺点：资源利用率低，可能导致饥饿")]),_._v(" "),a("h3",{attrs:{id:"_4-破坏循环等待条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-破坏循环等待条件"}},[_._v("#")]),_._v(" 4.破坏循环等待条件")]),_._v(" "),a("p",[_._v("可采用"),a("code",[_._v("顺序资源分配法")]),_._v("。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源。")]),_._v(" "),a("p",[_._v("一个进程只有已占有小编号的资源时，才有资格申请大编号的资源。")]),_._v(" "),a("p",[_._v("缺点：不方便增加新的设备，需要重新分配所有的编号。进程实际使用资源的顺序可能和序号递增顺序不一致，会导致资源浪费。必须按规定次序申请资源，用户编程麻烦")]),_._v(" "),a("h2",{attrs:{id:"_5-避免死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-避免死锁"}},[_._v("#")]),_._v(" 5.避免死锁")]),_._v(" "),a("h3",{attrs:{id:"_1-什么是安全序列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是安全序列"}},[_._v("#")]),_._v(" 1. 什么是安全序列")]),_._v(" "),a("p",[a("code",[_._v("安全序列：")]),_._v("就是指如果系统按照一种序列分配资源，则每个进程都能顺利完成。只要找到一个安全序列，系统就是"),a("code",[_._v("安全状态")]),_._v("。安全序列可以有多个。")]),_._v(" "),a("p",[_._v("如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了"),a("code",[_._v("不安全状态")]),_._v("。")]),_._v(" "),a("p",[_._v("如果系统处于"),a("code",[_._v("安全状态")]),_._v("，就"),a("code",[_._v("一定不发发生死锁")]),_._v("，如果系统进入"),a("code",[_._v("不安全状态")]),_._v("，就"),a("code",[_._v("可能发生死锁")]),_._v("。")]),_._v(" "),a("p",[_._v("但发生死锁时，一定是在不安全状态下。")]),_._v(" "),a("p",[a("code",[_._v("银行家算法：")]),_._v("在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。")]),_._v(" "),a("h3",{attrs:{id:"_2-银行家算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-银行家算法"}},[_._v("#")]),_._v(" 2.银行家算法")]),_._v(" "),a("p",[a("img",{attrs:{src:t(297),alt:"image-20221031164939094"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(298),alt:"image-20221031165025486"}})]),_._v(" "),a("h2",{attrs:{id:"_6-死锁的检测和解除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-死锁的检测和解除"}},[_._v("#")]),_._v(" 6.死锁的检测和解除")]),_._v(" "),a("h3",{attrs:{id:"_1-死锁的检测"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-死锁的检测"}},[_._v("#")]),_._v(" 1.死锁的检测")]),_._v(" "),a("p",[_._v("为了能对系统是否已经发生了死锁进行检测：")]),_._v(" "),a("ol",[a("li",[_._v("用"),a("code",[_._v("某种数据结构")]),_._v("来保存资源的请求和分配信息。")]),_._v(" "),a("li",[_._v("提供"),a("code",[_._v("一种算法")]),_._v("，利用上述信息来检测系统是否已经进入死锁状态")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(299),alt:"image-20221031170701813"}})]),_._v(" "),a("p",[_._v("如果系统中剩余的可用资源数足够"),a("code",[_._v("满足进程的需求")]),_._v("，那么这个进程暂时是不会阻塞的，可以顺利地执行下去，如果这个进程执行结束了，把资源归还给系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去")]),_._v(" "),a("p",[a("img",{attrs:{src:t(300),alt:"image-20221031174044568"}})]),_._v(" "),a("p",[_._v("如果不能消除"),a("code",[_._v("所有边")]),_._v("，那么就是发生了死锁。上面的图就是一个死锁")]),_._v(" "),a("p",[_._v("检测死锁的算法：")]),_._v(" "),a("ol",[a("li",[_._v("在资源分配图中，找出既不阻塞又不是孤点的进程Pi，就是可以消掉边的点，消去它的请求边和分配边，使之成为孤立的节点。在上图不是死锁的图中，P1满足，把P1的边消掉")]),_._v(" "),a("li",[_._v("进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程变为非阻塞进程。")]),_._v(" "),a("li",[_._v("如果消去所有的边，则称该图是"),a("code",[_._v("可完全简化的")])])]),_._v(" "),a("p",[a("code",[_._v("死锁定理：")]),_._v("如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁")]),_._v(" "),a("h3",{attrs:{id:"_2-解除死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-解除死锁"}},[_._v("#")]),_._v(" 2.解除死锁")]),_._v(" "),a("ol",[a("li",[a("code",[_._v("资源剥夺法。")]),_._v("挂起某些死锁进程，暂时放在外存，并剥夺它的资源，将这些资源分配给其他的死锁进程。")]),_._v(" "),a("li",[a("code",[_._v("撤销进程法。")]),_._v("强制撤销部分进程，甚至全部进程。并剥夺这些进程的资源。实现简单，代价大，会让已经快结束的进程功亏一篑")]),_._v(" "),a("li",[a("code",[_._v("进程回退法。")]),_._v("让一个或多个进程回退到足以避免死锁的地步，这就要求系统要记录进程的历史信息，设置还原点")])]),_._v(" "),a("h1",{attrs:{id:"二十三、内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二十三、内存"}},[_._v("#")]),_._v(" 二十三、内存")]),_._v(" "),a("blockquote",[a("p",[_._v("操作系统是系统资源的管理者，当然也需要对内存进行管理，需要管理的有：")]),_._v(" "),a("ol",[a("li",[_._v("负责"),a("code",[_._v("内存空间的分配与回收")])]),_._v(" "),a("li",[_._v("提供从逻辑上"),a("code",[_._v("对内存空间进行扩充")])]),_._v(" "),a("li",[_._v("提供"),a("code",[_._v("地址转换功能")]),_._v("，负责程序的逻辑地址与物理地址的转换")]),_._v(" "),a("li",[_._v("提供"),a("code",[_._v("内存保护")]),_._v("功能，保证各进程在各自存储空间内运行，互不干扰")])])]),_._v(" "),a("p",[_._v("在内存中编译时，只关心"),a("code",[_._v("相对位置")]),_._v("，实际放入内存时，再想办法根据起始位置得到"),a("code",[_._v("绝对地址")])]),_._v(" "),a("p",[a("code",[_._v("相对地址")]),_._v("又称"),a("code",[_._v("逻辑地址")]),_._v("，"),a("code",[_._v("绝对地址")]),_._v("又称"),a("code",[_._v("物理地址")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(301),alt:"image-20221031193032345"}})]),_._v(" "),a("h2",{attrs:{id:"_1-装入方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-装入方式"}},[_._v("#")]),_._v(" 1.装入方式")]),_._v(" "),a("p",[_._v("装入的三种方式（用三种不同的方法完成"),a("code",[_._v("逻辑地址 到 物理地址 的转换")]),_._v("）：")]),_._v(" "),a("ol",[a("li",[_._v("绝对装入\n在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存")]),_._v(" "),a("li",[_._v("静态重定位\n"),a("img",{attrs:{src:t(302),alt:"image-20221031192754718"}})]),_._v(" "),a("li",[_._v("动态重定位\n"),a("img",{attrs:{src:t(303),alt:"image-20221031192929747"}})])]),_._v(" "),a("h2",{attrs:{id:"_2-链接方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-链接方式"}},[_._v("#")]),_._v(" 2.链接方式")]),_._v(" "),a("p",[a("img",{attrs:{src:t(304),alt:"image-20221031193340739"}})]),_._v(" "),a("h2",{attrs:{id:"_3-内存保护"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-内存保护"}},[_._v("#")]),_._v(" 3.内存保护")]),_._v(" "),a("p",[a("img",{attrs:{src:t(305),alt:"image-20221031195146659"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(306),alt:"image-20221031195256953"}})]),_._v(" "),a("h2",{attrs:{id:"_4-覆盖与交换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-覆盖与交换"}},[_._v("#")]),_._v(" 4.覆盖与交换")]),_._v(" "),a("p",[_._v("计算机内存较小，无法把一个大型软件全部运行")]),_._v(" "),a("p",[_._v("之后引入"),a("code",[_._v("覆盖技术")]),_._v("，用来"),a("code",[_._v("解决“程序大小超过物理内存总和”")]),_._v("的问题")]),_._v(" "),a("p",[_._v("覆盖技术思想：将"),a("code",[_._v("程序分为多个段")]),_._v("，常用的段常驻内存，不常用的段在需要时调入内存")]),_._v(" "),a("p",[_._v("内存中分为一个"),a("code",[_._v("“固定区”")]),_._v("，和若干个"),a("code",[_._v("“覆盖区”")])]),_._v(" "),a("p",[_._v("需要常驻内存的段放在"),a("code",[_._v("固定区")]),_._v("，调入后就不再调出，除非运行结束")]),_._v(" "),a("p",[_._v("不常用的段放在"),a("code",[_._v("“覆盖区”")]),_._v("，需要用时调入内存，用不到时调出内存")]),_._v(" "),a("p",[a("img",{attrs:{src:t(307),alt:"image-20221031201127995"}})]),_._v(" "),a("p",[a("code",[_._v("交换技术设计思想")]),_._v("：内存空间紧张时，系统将内存中某些进程暂时调出外存，把外存中某些已具备运行条件的进程换入内存")]),_._v(" "),a("p",[a("img",{attrs:{src:t(308),alt:"image-20221031202417496"}}),_._v("\nz\n"),a("img",{attrs:{src:t(309),alt:"image-20221031202730509"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(310),alt:"image-20221031203139203"}})]),_._v(" "),a("h2",{attrs:{id:"_5-内存空间的分配与回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-内存空间的分配与回收"}},[_._v("#")]),_._v(" 5.内存空间的分配与回收")]),_._v(" "),a("p",[a("code",[_._v("内部碎片：")]),_._v("分配个某进程的内存区域中，如果有些部分没有用上")]),_._v(" "),a("p",[a("code",[_._v("外部碎片：")]),_._v("是指内存中的某些空闲分区由于太小而难以利用")]),_._v(" "),a("h3",{attrs:{id:"_1-连续分配管理方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-连续分配管理方式"}},[_._v("#")]),_._v(" （1）连续分配管理方式")]),_._v(" "),a("p",[_._v("为用户分配一段连续的内存空间")]),_._v(" "),a("blockquote",[a("p",[a("strong",[_._v("单一连续分配")])])]),_._v(" "),a("p",[_._v("在单一连续分配方式中，内存被分为"),a("code",[_._v("系统区")]),_._v("和"),a("code",[_._v("用户区")]),_._v("。系统区通常位于内存的低地址部分，用于存放操作系统相关数据。用户区用于存放用于进程相关数据。")]),_._v(" "),a("p",[_._v("单一连续分配"),a("code",[_._v("只能有一道用户程序")]),_._v("，用户程序独占整个用户区空间。")]),_._v(" "),a("p",[_._v("有点：实现简单，无外部碎片；可以采用覆盖技术扩充内存。不一定需要采取内存保护")]),_._v(" "),a("p",[_._v("用于早期的计算机系统")]),_._v(" "),a("p",[_._v("缺点：只能用于单用户，单任务的操作系统中，有"),a("code",[_._v("内部碎片")]),_._v("，存储器 利用率极低。")]),_._v(" "),a("p",[a("code",[_._v("内部碎片：")]),_._v("分配给某进程的内存区域中，有些部分没有用上，就是内部碎片")]),_._v(" "),a("p",[a("img",{attrs:{src:t(311),alt:"image-20221101111712854"}})]),_._v(" "),a("blockquote",[a("p",[a("strong",[_._v("固定分区分配")])])]),_._v(" "),a("p",[_._v("20世纪60年代，出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会互相干扰，于是将整个"),a("code",[_._v("用户空间")]),_._v("划分为"),a("code",[_._v("若干个固定大小的分区")]),_._v("，在"),a("code",[_._v("每个分区中只装入一道作业")]),_._v("。")]),_._v(" "),a("p",[a("img",{attrs:{src:t(312),alt:"image-20221101111834019"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(313),alt:"image-20221101111859551"}})]),_._v(" "),a("p",[_._v("分区大小相等：缺乏灵活性，但是很"),a("code",[_._v("适合用于一台计算机控制多个相同对象的场合")])]),_._v(" "),a("p",[_._v("分区大小不等：增加了灵活性，可以满足不同大小的进程需求。")]),_._v(" "),a("p",[_._v("操作系统需要建立一个数据结构>"),a("code",[_._v("分区说明表")]),_._v("，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列，每个表项包括对应分区的"),a("code",[_._v("大小、起始地址、状态")]),_._v("，")]),_._v(" "),a("p",[a("img",{attrs:{src:t(314),alt:"image-20221102090746058"}})]),_._v(" "),a("p",[_._v("当用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的，未分配的分区，将分区分配给该程序，然后状态改为：已分配")]),_._v(" "),a("p",[_._v("优点：实现简单，"),a("code",[_._v("无外部碎片")])]),_._v(" "),a("p",[_._v("缺点：1.程序太大时，需要采用覆盖技术，覆盖技术又会降低性能。2.会产生内部碎片，内存利用率低")]),_._v(" "),a("blockquote",[a("p",[a("strong",[_._v("动态分区分配")])])]),_._v(" "),a("p",[_._v("又称"),a("code",[_._v("可变分区分配")]),_._v("，这种分配方式，"),a("code",[_._v("不会预先划分内存区")]),_._v("，在程序装入内存时，根据"),a("code",[_._v("进程的大小动态的创建分区")]),_._v("，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。")]),_._v(" "),a("p",[a("img",{attrs:{src:t(315),alt:"image-20221102091650516"}})]),_._v(" "),a("ol",[a("li",[a("p",[_._v("系统要用什么样的数据结构记录内存的使用情况\n两种数据结构："),a("code",[_._v("空闲分区表")]),_._v("和"),a("code",[_._v("空闲分区链")]),_._v(" "),a("img",{attrs:{src:t(316),alt:"image-20221102092150308"}}),_._v(" "),a("img",{attrs:{src:t(317),alt:"image-20221102092242912"}})])]),_._v(" "),a("li",[a("p",[_._v("当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配")]),_._v(" "),a("p",[a("img",{attrs:{src:t(318),alt:"image-20221102095610234"}})]),_._v(" "),a("p",[_._v("（1）首次适应算法\n"),a("code",[_._v("算法思想：")]),_._v("每次都从低地址开始查找，找到第一个能满足大小的空闲分区\n"),a("code",[_._v("实现方法：")]),_._v("空闲分区表以"),a("code",[_._v("地址递增的次序排列")]),_._v("，每次分配内存时，按顺序查找空闲分区链，找到第一个满足的空闲分区")]),_._v(" "),a("p",[_._v("（2）最佳适应算法")]),_._v(" "),a("p",[_._v("​\t"),a("code",[_._v("算法思想：")]),_._v("为了在大进程来到的时候，有大片空闲分区，所以优先使用最小的空闲区")]),_._v(" "),a("p",[_._v("​\t"),a("code",[_._v("实现：")]),_._v("空闲分区表按"),a("code",[_._v("容量递增次序排列")]),_._v("，每次分配内存时，按顺序查找空闲分区表或链，找到的第一个空闲分区，就是最小的满足进程的分区")]),_._v(" "),a("p",[_._v("（3）最坏适应算法")]),_._v(" "),a("p",[_._v("又称"),a("code",[_._v("最大适应算法")])]),_._v(" "),a("p",[_._v("​\t"),a("code",[_._v("算法思想：")]),_._v("为了解决最佳适应算法遗留的问题：留下太多难以利用的小碎片。在每次分配时优先使用最大的连续空闲区，这样留下的空闲分区不会太小")]),_._v(" "),a("p",[_._v("​\t"),a("code",[_._v("实现：")]),_._v("按"),a("code",[_._v("容量递减次序排序")]),_._v("，按顺序查找，找到大小满足的第一个空闲分区\n​\t"),a("code",[_._v("缺点：")]),_._v("没有给大进程留足够的空闲分区")]),_._v(" "),a("p",[_._v("（4）邻近适应算法")]),_._v(" "),a("p",[_._v("​\t"),a("code",[_._v("算法思想：")]),_._v("每次查找都从上次查找结束的位置开始检索。解决了每次从链头查找的开销")]),_._v(" "),a("p",[_._v("​\t"),a("code",[_._v("实现：")]),_._v("空闲分区以"),a("code",[_._v("地址递增循环排列")]),_._v("，形成一个循环链表，每次分配内存时，从上次查找结束的位置开始查找空闲分区链，找到第一个能满足的空闲分区")])]),_._v(" "),a("li",[a("p",[_._v("如何进行分区的分配和回收操作\n"),a("img",{attrs:{src:t(319),alt:"image-20221102092616982"}}),_._v("\n(1)当有一个4MB的进程需要分配，有两种方式：\n分给分区1："),a("img",{attrs:{src:t(320),alt:"image-20221102092842674"}}),_._v("\n分给分区3："),a("img",{attrs:{src:t(321),alt:"image-20221102092920450"}}),_._v("\n(2)当有程序执行完，需要回收：\n情况1：进程4回收之后\n"),a("img",{attrs:{src:t(322),alt:"image-20221102093258945"}}),_._v(" "),a("img",{attrs:{src:t(323),alt:"image-20221102093340707"}}),_._v("\n情况2：进程3回收之后\n"),a("img",{attrs:{src:t(324),alt:"image-20221102093612368"}}),_._v("\n情况3：进程4回收之后\n"),a("img",{attrs:{src:t(325),alt:"image-20221102093750188"}}),_._v("\n情况4：进程2回收之后\n"),a("img",{attrs:{src:t(326),alt:"image-20221102093929988"}})])])]),_._v(" "),a("h3",{attrs:{id:"_2-非连续分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-非连续分配"}},[_._v("#")]),_._v(" （2）非连续分配")]),_._v(" "),a("p",[_._v("为用户进程分配的可以是一些离散的内存空间")]),_._v(" "),a("p",[_._v("==由于太多，不适合在三级标题下记录，因此在此处使用一级标题来笔记"),a("code",[_._v("分页存储")]),_._v("==")]),_._v(" "),a("h1",{attrs:{id:"二十四、分页存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二十四、分页存储"}},[_._v("#")]),_._v(" 二十四、分页存储")]),_._v(" "),a("h2",{attrs:{id:"_1-基本分页存储管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本分页存储管理"}},[_._v("#")]),_._v(" 1.基本分页存储管理")]),_._v(" "),a("h3",{attrs:{id:"_1-基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本概念"}},[_._v("#")]),_._v(" 1.基本概念")]),_._v(" "),a("p",[_._v("将内存空间分为一个个"),a("code",[_._v("大小相等的分区")]),_._v("，比如每个分区4kb，每个分区就是一个"),a("code",[_._v("页框")]),_._v("，也可以叫"),a("code",[_._v("页帧")]),_._v("、"),a("code",[_._v("内存块")]),_._v("、"),a("code",[_._v("物理块")]),_._v("。每个页框有一个编号，即"),a("code",[_._v("页框号")]),_._v("，又叫"),a("code",[_._v("内存块号")]),_._v("、"),a("code",[_._v("页帧号")]),_._v("、"),a("code",[_._v("物理块号")]),_._v("，"),a("strong",[_._v("页框号从0开始")])]),_._v(" "),a("p",[_._v("将用户进程的地址空间也分为"),a("code",[_._v("与页框大小相等")]),_._v("的多个区域，称为"),a("code",[_._v("页")]),_._v("或"),a("code",[_._v("页面")]),_._v("。每个页面也有一个编号，即"),a("code",[_._v("页号")]),_._v("，也是"),a("strong",[_._v("从0开始")])]),_._v(" "),a("p",[_._v("页框不能太大，否则会产生过大的内部碎片")]),_._v(" "),a("p",[_._v("操作系统把一个进程分为的多个页面分配进内存空间，分别放入一个页框中，所以，"),a("code",[_._v("页面")]),_._v("与"),a("code",[_._v("页框")]),_._v("有个"),a("code",[_._v("一一对应")]),_._v("的关系。")]),_._v(" "),a("p",[_._v("各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中")]),_._v(" "),a("h3",{attrs:{id:"_2-地址转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-地址转换"}},[_._v("#")]),_._v(" 2.地址转换")]),_._v(" "),a("p",[_._v("分页存储的地址转换")]),_._v(" "),a("p",[a("img",{attrs:{src:t(327),alt:"image-20221102111036716"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(328),alt:"image-20221102111440035"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(329),alt:"image-20221102175225458"}})]),_._v(" "),a("p",[a("strong",[_._v("逻辑地址结构")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(330),alt:"image-20221102175402749"}})]),_._v(" "),a("p",[_._v("为了知道"),a("code",[_._v("页号")]),_._v("对应页面在内存中的地址，有如下页表")]),_._v(" "),a("p",[a("img",{attrs:{src:t(331),alt:"image-20221102175619073"}})]),_._v(" "),a("h3",{attrs:{id:"_3-基本地址变换机构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-基本地址变换机构"}},[_._v("#")]),_._v(" 3.基本地址变换机构")]),_._v(" "),a("p",[_._v("基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。")]),_._v(" "),a("p",[_._v("通常会在系统中设置一个"),a("code",[_._v("页表寄存器（PTR）")]),_._v("，存放的是"),a("code",[_._v("页表在内存中的起始地址F")]),_._v("和"),a("code",[_._v("页表长度M")]),_._v("。")]),_._v(" "),a("p",[_._v("进程未执行时，页表的F和M"),a("code",[_._v("存放在进程控制块（PCB）中")]),_._v("，当进程被调度时，操作系统内核会把它们放到页面寄存器中")]),_._v(" "),a("p",[_._v("流程：")]),_._v(" "),a("p",[a("img",{attrs:{src:t(332),alt:"image-20221102181311637"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(333),alt:"image-20221102181213999"}})]),_._v(" "),a("p",[a("strong",[_._v("例题：")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(334),alt:"image-20221102181604763"}})]),_._v(" "),a("h3",{attrs:{id:"_4-具有快表的地址变换机构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-具有快表的地址变换机构"}},[_._v("#")]),_._v(" 4.具有快表的地址变换机构")]),_._v(" "),a("h4",{attrs:{id:"局部性原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#局部性原理"}},[_._v("#")]),_._v(" 局部性原理")]),_._v(" "),a("p",[a("img",{attrs:{src:t(335),alt:"image-20221102183517198"}})]),_._v(" "),a("h4",{attrs:{id:"什么是快表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是快表"}},[_._v("#")]),_._v(" 什么是快表")]),_._v(" "),a("p",[a("code",[_._v("快表")]),_._v("，又称"),a("code",[_._v("联想寄存器（TLB）")]),_._v("，是一种"),a("code",[_._v("访问速度比内存快很多")]),_._v("的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为"),a("code",[_._v("慢表")])]),_._v(" "),a("p",[_._v("快表流程：")]),_._v(" "),a("p",[a("img",{attrs:{src:t(336),alt:"image-20221102184153075"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(337),alt:"image-20221102184033463"}})]),_._v(" "),a("h3",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[_._v("#")]),_._v(" 小结")]),_._v(" "),a("p",[a("img",{attrs:{src:t(338),alt:"image-20221102184254885"}})]),_._v(" "),a("h2",{attrs:{id:"_2-两级页表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-两级页表"}},[_._v("#")]),_._v(" 2.两级页表")]),_._v(" "),a("p",[_._v("单级页表存在的问题：")]),_._v(" "),a("p",[_._v("问题1：页表必须连续存放，因此当页表很大时，需要占用多个连续的页框")]),_._v(" "),a("p",[_._v("问题2：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面")]),_._v(" "),a("h3",{attrs:{id:"解决问题1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决问题1"}},[_._v("#")]),_._v(" 解决问题1")]),_._v(" "),a("p",[_._v("可将长页表进行分组，使每个内存块刚好可以放入一个分组。")]),_._v(" "),a("p",[_._v("要为离散分配的页表再建立一张表，成为"),a("code",[_._v("页目录表")]),_._v("，或称"),a("code",[_._v("外层页表")]),_._v("、"),a("code",[_._v("顶层页表")])]),_._v(" "),a("p",[_._v("图示：")]),_._v(" "),a("p",[a("img",{attrs:{src:t(339),alt:"image-20221102195022772"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(340),alt:"image-20221102195354719"}})]),_._v(" "),a("p",[_._v("如何实现地址转换：")]),_._v(" "),a("p",[a("img",{attrs:{src:t(341),alt:"image-20221102195606238"}}),_._v(" "),a("img",{attrs:{src:t(342),alt:"image-20221102195606238"}})])])}),[],!1,null,null,null);a.default=s.exports}}]);