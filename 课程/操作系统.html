<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一、操作系统 | EricKiku</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/faviron.ico">
    <meta name="description" content="EricKiku的博客">
    <meta name="keywords" content="erickiku,vuepress,html,前端">
    
    <link rel="preload" href="/assets/css/0.styles.d6ad21ed.css" as="style"><link rel="preload" href="/assets/js/app.5555aa2a.js" as="script"><link rel="preload" href="/assets/js/3.dce90c24.js" as="script"><link rel="preload" href="/assets/js/2.5b478fa2.js" as="script"><link rel="prefetch" href="/assets/js/10.2773de59.js"><link rel="prefetch" href="/assets/js/11.96aa92c3.js"><link rel="prefetch" href="/assets/js/12.f672ebf4.js"><link rel="prefetch" href="/assets/js/13.a82dee11.js"><link rel="prefetch" href="/assets/js/14.b1128d46.js"><link rel="prefetch" href="/assets/js/15.6ad5d42b.js"><link rel="prefetch" href="/assets/js/16.15d3e7dd.js"><link rel="prefetch" href="/assets/js/17.ae1b8542.js"><link rel="prefetch" href="/assets/js/18.8b936cb5.js"><link rel="prefetch" href="/assets/js/19.3bb0191b.js"><link rel="prefetch" href="/assets/js/20.37e6021f.js"><link rel="prefetch" href="/assets/js/21.a19a5de0.js"><link rel="prefetch" href="/assets/js/22.3f58dff8.js"><link rel="prefetch" href="/assets/js/23.3e7d266d.js"><link rel="prefetch" href="/assets/js/24.b98b128d.js"><link rel="prefetch" href="/assets/js/25.c52e388a.js"><link rel="prefetch" href="/assets/js/26.f4ef0bd5.js"><link rel="prefetch" href="/assets/js/27.2f993f3f.js"><link rel="prefetch" href="/assets/js/4.ceb62bf4.js"><link rel="prefetch" href="/assets/js/5.02478516.js"><link rel="prefetch" href="/assets/js/6.e6a2c7e8.js"><link rel="prefetch" href="/assets/js/7.e0636205.js"><link rel="prefetch" href="/assets/js/8.3bbc22f5.js"><link rel="prefetch" href="/assets/js/9.9c502922.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d6ad21ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/hero.png" alt="EricKiku" class="logo"> <span class="site-name can-hide">EricKiku</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end/css.html" class="nav-link">
  HTML+CSS
</a></li><li class="dropdown-item"><!----> <a href="/front-end/js.html" class="nav-link">
  JS
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端进阶" class="mobile-dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontPro/ajax.html" class="nav-link">
  Ajax
</a></li><li class="dropdown-item"><!----> <a href="/frontPro/axios.html" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontPro/git.html" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/frontPro/node.html" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><h4>
          WebPack
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/frontPro/webpack5.html" class="nav-link">
  webpack5
</a></li><li class="dropdown-subitem"><a href="/frontPro/webpack5高级.html" class="nav-link">
  webpack5高级
</a></li><li class="dropdown-subitem"><a href="/frontPro/webpack5模式.html" class="nav-link">
  webpack5模式
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/frontPro/typescript.html" class="nav-link">
  TypeScript
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">Vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Vue
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/vue/vue2.html" class="nav-link">
  vue2
</a></li><li class="dropdown-subitem"><a href="/vue/vue3.html" class="nav-link">
  vue3
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/vue/vuerouter.html" class="nav-link">
  VueRouter
</a></li><li class="dropdown-item"><!----> <a href="/vue/vuex.html" class="nav-link">
  VueX
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="ES6" class="dropdown-title"><span class="title">ES6</span> <span class="arrow down"></span></button> <button type="button" aria-label="ES6" class="mobile-dropdown-title"><span class="title">ES6</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ES6/es6.html" class="nav-link">
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/ES6/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="源码" class="dropdown-title"><span class="title">源码</span> <span class="arrow down"></span></button> <button type="button" aria-label="源码" class="mobile-dropdown-title"><span class="title">源码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/源码/mustache.html" class="nav-link">
  mustache
</a></li><li class="dropdown-item"><!----> <a href="/ES6/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于我" class="dropdown-title"><span class="title">EricKiku</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于我" class="mobile-dropdown-title"><span class="title">EricKiku</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/EricKiku" target="_blank" rel="noopener noreferrer" class="nav-link external">
  我的GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.erickiku.xyz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  我的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><h4>
          我的系统
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="http://www.erickiku.xyz:5001" target="_blank" rel="noopener noreferrer" class="nav-link external">
  请假系统
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="http://39.98.110.164:5555" target="_blank" rel="noopener noreferrer" class="nav-link external">
  井字棋游戏
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end/css.html" class="nav-link">
  HTML+CSS
</a></li><li class="dropdown-item"><!----> <a href="/front-end/js.html" class="nav-link">
  JS
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端进阶" class="mobile-dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontPro/ajax.html" class="nav-link">
  Ajax
</a></li><li class="dropdown-item"><!----> <a href="/frontPro/axios.html" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontPro/git.html" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/frontPro/node.html" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><h4>
          WebPack
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/frontPro/webpack5.html" class="nav-link">
  webpack5
</a></li><li class="dropdown-subitem"><a href="/frontPro/webpack5高级.html" class="nav-link">
  webpack5高级
</a></li><li class="dropdown-subitem"><a href="/frontPro/webpack5模式.html" class="nav-link">
  webpack5模式
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/frontPro/typescript.html" class="nav-link">
  TypeScript
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">Vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Vue
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/vue/vue2.html" class="nav-link">
  vue2
</a></li><li class="dropdown-subitem"><a href="/vue/vue3.html" class="nav-link">
  vue3
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/vue/vuerouter.html" class="nav-link">
  VueRouter
</a></li><li class="dropdown-item"><!----> <a href="/vue/vuex.html" class="nav-link">
  VueX
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="ES6" class="dropdown-title"><span class="title">ES6</span> <span class="arrow down"></span></button> <button type="button" aria-label="ES6" class="mobile-dropdown-title"><span class="title">ES6</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/ES6/es6.html" class="nav-link">
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/ES6/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="源码" class="dropdown-title"><span class="title">源码</span> <span class="arrow down"></span></button> <button type="button" aria-label="源码" class="mobile-dropdown-title"><span class="title">源码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/源码/mustache.html" class="nav-link">
  mustache
</a></li><li class="dropdown-item"><!----> <a href="/ES6/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于我" class="dropdown-title"><span class="title">EricKiku</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于我" class="mobile-dropdown-title"><span class="title">EricKiku</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/EricKiku" target="_blank" rel="noopener noreferrer" class="nav-link external">
  我的GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.erickiku.xyz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  我的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><h4>
          我的系统
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="http://www.erickiku.xyz:5001" target="_blank" rel="noopener noreferrer" class="nav-link external">
  请假系统
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="http://39.98.110.164:5555" target="_blank" rel="noopener noreferrer" class="nav-link external">
  井字棋游戏
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>课程</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/课程/操作系统.html" class="active sidebar-link">操作系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-操作系统层次" class="sidebar-link">1. 操作系统层次</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-定义" class="sidebar-link">2.定义</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-系统资源的管理者" class="sidebar-link">1.系统资源的管理者</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-作为硬件和用户之间的接口" class="sidebar-link">2.作为硬件和用户之间的接口</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-并发" class="sidebar-link">1.并发</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-共享" class="sidebar-link">2.共享</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#并发和共享的关系" class="sidebar-link">并发和共享的关系</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-虚拟" class="sidebar-link">3.虚拟</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_4-异步" class="sidebar-link">4.异步</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-手工操作阶段" class="sidebar-link">1.手工操作阶段</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-单道批处理系统" class="sidebar-link">2.单道批处理系统</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-多道批处理系统" class="sidebar-link">3.多道批处理系统</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_4-分时操作系统" class="sidebar-link">4.分时操作系统</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_5-实时操作系统" class="sidebar-link">5.实时操作系统</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-运行机制" class="sidebar-link">1. 运行机制</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-操作系统的内核" class="sidebar-link">2.操作系统的内核</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-操作系统体系结构" class="sidebar-link">3.操作系统体系结构</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-中断的概念和作用" class="sidebar-link">1.中断的概念和作用</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-中断的分类" class="sidebar-link">2.中断的分类</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-进程的组成" class="sidebar-link">1. 进程的组成</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-进程的组织" class="sidebar-link">2. 进程的组织</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-进程的特征" class="sidebar-link">3.进程的特征</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-进程的状态" class="sidebar-link">1. 进程的状态</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-进程的转换" class="sidebar-link">2.进程的转换</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-原语" class="sidebar-link">1.原语</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-共享存储" class="sidebar-link">1.共享存储</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-管道通信" class="sidebar-link">2.管道通信</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-消息传递" class="sidebar-link">3. 消息传递</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-什么是线程" class="sidebar-link">1. 什么是线程</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-线程的属性" class="sidebar-link">2.线程的属性</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-线程的实现方式" class="sidebar-link">3.线程的实现方式</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_4-多线程" class="sidebar-link">4.多线程</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-调度概念" class="sidebar-link">1. 调度概念</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-三个层次" class="sidebar-link">2. 三个层次</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-进程调度时机" class="sidebar-link">3. 进程调度时机</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_4-进程调度的方式" class="sidebar-link">4. 进程调度的方式</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_5-进程切换与过程" class="sidebar-link">5. 进程切换与过程</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_6-调度算法指标" class="sidebar-link">6. 调度算法指标</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-fcfs" class="sidebar-link">1. FCFS</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-sjf" class="sidebar-link">2. SJF</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-hrrn" class="sidebar-link">3. HRRN</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_4-rr" class="sidebar-link">4.RR</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_5-优先级调度算法" class="sidebar-link">5. 优先级调度算法</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_6-多级反馈队列调度" class="sidebar-link">6. 多级反馈队列调度</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-进程同步" class="sidebar-link">1.进程同步</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-进程互斥" class="sidebar-link">2.进程互斥</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-进程互斥的软件实现" class="sidebar-link">3.进程互斥的软件实现</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_4-进程互斥的硬件实现" class="sidebar-link">4.进程互斥的硬件实现</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-整形信号量" class="sidebar-link">1. 整形信号量</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-记录型信号量" class="sidebar-link">2. 记录型信号量</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-信号量机制实现进程互斥" class="sidebar-link">3. 信号量机制实现进程互斥</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_4-信号量机制实现进程同步" class="sidebar-link">4. 信号量机制实现进程同步</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_5-实现进程的同步关系" class="sidebar-link">5.实现进程的同步关系</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-多生产者多消费者" class="sidebar-link">1. 多生产者多消费者</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-管程解决生产者消费者问题" class="sidebar-link">1.管程解决生产者消费者问题</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-死锁、饥饿、死循环" class="sidebar-link">1.死锁、饥饿、死循环</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-死锁发生的条件" class="sidebar-link">2.死锁发生的条件</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-死锁的处理策略" class="sidebar-link">3.死锁的处理策略</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_4-预防死锁" class="sidebar-link">4.预防死锁</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_5-避免死锁" class="sidebar-link">5.避免死锁</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_6-死锁的检测和解除" class="sidebar-link">6.死锁的检测和解除</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-装入方式" class="sidebar-link">1.装入方式</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-链接方式" class="sidebar-link">2.链接方式</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_3-内存保护" class="sidebar-link">3.内存保护</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_4-覆盖与交换" class="sidebar-link">4.覆盖与交换</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_5-内存空间的分配与回收" class="sidebar-link">5.内存空间的分配与回收</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_1-基本分页存储管理" class="sidebar-link">1.基本分页存储管理</a></li><li class="sidebar-sub-header"><a href="/课程/操作系统.html#_2-两级页表" class="sidebar-link">2.两级页表</a></li></ul></li><li><a href="/课程/日语.html" class="sidebar-link">日语</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一、操作系统"><a href="#一、操作系统" class="header-anchor">#</a> 一、操作系统</h1> <h2 id="_1-操作系统层次"><a href="#_1-操作系统层次" class="header-anchor">#</a> 1. 操作系统层次</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221024155305809.png" alt="image-20221024155305809"></p> <h2 id="_2-定义"><a href="#_2-定义" class="header-anchor">#</a> 2.定义</h2> <p><code>操作系统</code>(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供用户和其他软件方便的接口和环境，它是计算机系统中最基本的<code>系统软件</code></p> <h1 id="二、操作系统功能和目标"><a href="#二、操作系统功能和目标" class="header-anchor">#</a> 二、操作系统功能和目标</h1> <h2 id="_1-系统资源的管理者"><a href="#_1-系统资源的管理者" class="header-anchor">#</a> 1.系统资源的管理者</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221024160818996.png" alt="image-20221024160818996"></p> <h2 id="_2-作为硬件和用户之间的接口"><a href="#_2-作为硬件和用户之间的接口" class="header-anchor">#</a> 2.作为硬件和用户之间的接口</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221025090622134.png" alt="image-20221025090622134"></p> <p>用户接口：</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221025092059509.png" alt="image-20221025092059509"></p> <h1 id="三、操作系统4个特征"><a href="#三、操作系统4个特征" class="header-anchor">#</a> 三、操作系统4个特征</h1> <p>​</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221025093101472.png" alt="image-20221025093101472"></p> <h2 id="_1-并发"><a href="#_1-并发" class="header-anchor">#</a> 1.并发</h2> <p><code>并发</code>：指两个或多个事件在同一时间间隔发生。这些事件<code>宏观上是同时发生</code>,但<code>微观上是交替发生的</code></p> <p><code>并行</code>：指两个或多个事件在同一时刻同时发生</p> <h2 id="_2-共享"><a href="#_2-共享" class="header-anchor">#</a> 2.共享</h2> <p><code>共享</code>：即资源共享，是指系统中的资源可供内存中多个并发执行的进程使用共同使用</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221025093849891.png" alt="image-20221025093849891"></p> <p>所谓同时，也是宏观上的，微观上，这些进程可能也是交替进行的</p> <h2 id="并发和共享的关系"><a href="#并发和共享的关系" class="header-anchor">#</a> 并发和共享的关系</h2> <p>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</p> <p>如果失去共享性，则QQ和微信等不能同时访问硬盘资源，就无法实现同步发送文件，也就无法并发</p> <h2 id="_3-虚拟"><a href="#_3-虚拟" class="header-anchor">#</a> 3.虚拟</h2> <p><code>虚拟</code>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上市用户感受到的。</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221025095831537.png" alt="image-20221025095831537"></p> <h2 id="_4-异步"><a href="#_4-异步" class="header-anchor">#</a> 4.异步</h2> <p><code>异步</code>是指，在多到程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是以某种顺序向前推进</p> <h1 id="四、操作系统的发展与分类"><a href="#四、操作系统的发展与分类" class="header-anchor">#</a> 四、操作系统的发展与分类</h1> <h2 id="_1-手工操作阶段"><a href="#_1-手工操作阶段" class="header-anchor">#</a> 1.手工操作阶段</h2> <p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低</p> <h2 id="_2-单道批处理系统"><a href="#_2-单道批处理系统" class="header-anchor">#</a> 2.单道批处理系统</h2> <p>引入了<code>脱机输入/输出技术</code>，使用磁带完成。并<code>监督程序</code>负责控制作业的输入、输出</p> <p>监督程序就是操作系统的雏形</p> <p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p> <p>主要缺点：<code>内存中仅能有一道程序运行</code>，只有程序结束之后才能调入下一道程序。<code>CPU有大量的时间在空闲等待I/O完成</code>。资源利用率依然很低</p> <h2 id="_3-多道批处理系统"><a href="#_3-多道批处理系统" class="header-anchor">#</a> 3.多道批处理系统</h2> <p>操作系统正式诞生。</p> <p>主要优点：多道程序<code>并发</code>执行，<code>共享</code>计算机资源。<code>资源利用率大幅提升</code>，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</p> <p>主要缺点：用户响应时间长，<code>没有人机交互功能</code>，用户提交之后不能控制自己作业的执行，只能等待计算机处理完成</p> <h2 id="_4-分时操作系统"><a href="#_4-分时操作系统" class="header-anchor">#</a> 4.分时操作系统</h2> <p>分时操作系统：计算机以<code>时间片</code>为单位<code>轮流为各个用户服务</code>，各个用户可以通过终端与计算机进行交互。</p> <p>主要优点：用户请求可以被即是响应，解决人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到其他人的存在</p> <p>主要缺点：<code>不能优先处理一些紧急任务</code>，操作系统对每个用户都是完全公平的，循环地为每个用户服务一个时间片，不区分任务的紧急性</p> <h2 id="_5-实时操作系统"><a href="#_5-实时操作系统" class="header-anchor">#</a> 5.实时操作系统</h2> <p>计算机系统接收到信号之后及时进行处理，并且要在规定时间内处理完成事件。实时操作系统的主要特点是<code>及时性和可靠性</code></p> <p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需要排队</p> <p>​	<img src="http://www.erickiku.xyz/typora-images%5Cimage-20221025192855776.png" alt="image-20221025192855776"></p> <h1 id="五、os的运行机制和体系结构"><a href="#五、os的运行机制和体系结构" class="header-anchor">#</a> 五、OS的运行机制和体系结构</h1> <h2 id="_1-运行机制"><a href="#_1-运行机制" class="header-anchor">#</a> 1. 运行机制</h2> <h3 id="_1-两种指令"><a href="#_1-两种指令" class="header-anchor">#</a> （1）两种指令</h3> <ul><li><p>特权指令：高危指令，比如内存清空指令。<code>用户程序无法使用</code></p></li> <li><p>非特权指令：普通指令。<code>用户程序可以使用</code></p></li></ul> <h3 id="_2-两种处理器状态"><a href="#_2-两种处理器状态" class="header-anchor">#</a> （2）两种处理器状态</h3> <ul><li><p>用户态(目态)：此时CPU只能执行非特权指令</p></li> <li><p>和心态(管态)：特权指令，非特权指令都可以执行</p></li></ul> <blockquote><p>使用程序状态字寄存器（PSW)中的某标志位来标识当前处理器处于什么状态</p></blockquote> <h3 id="_3-两种程序"><a href="#_3-两种程序" class="header-anchor">#</a> （3）两种程序</h3> <ul><li>内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态</li> <li>应用程序：普通应用程序只能执行非特权指令，运行在用户态</li></ul> <h2 id="_2-操作系统的内核"><a href="#_2-操作系统的内核" class="header-anchor">#</a> 2.操作系统的内核</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221025194519627.png" alt="image-20221025194519627"></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221025194553756.png" alt="image-20221025194553756"></p> <h2 id="_3-操作系统体系结构"><a href="#_3-操作系统体系结构" class="header-anchor">#</a> 3.操作系统体系结构</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221025194942189.png" alt="image-20221025194942189"></p> <h1 id="六、中断和异常"><a href="#六、中断和异常" class="header-anchor">#</a> 六、中断和异常</h1> <h2 id="_1-中断的概念和作用"><a href="#_1-中断的概念和作用" class="header-anchor">#</a> 1.中断的概念和作用</h2> <ol><li>当中断发生时，CPU立即进入<code>核心态</code></li> <li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li> <li>对于不同的中断信号，会进行不同的处理</li></ol> <p>发生中断，就意味着需要操作系统介入，开始管理工作，由于操作系统的管理工作需要使用特权指令，所以需要CPU<code>从用户态转为核心态，使操作系统获得计算机的控制权</code>，有了中断，才能实现多道程序并发执行</p> <p><code>用户态到核心态</code>是通过中断实现的，并且只有中断这一个途径</p> <h2 id="_2-中断的分类"><a href="#_2-中断的分类" class="header-anchor">#</a> 2.中断的分类</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026080950359.png" alt="image-20221026080950359"></p> <h3 id="外中断处理过程"><a href="#外中断处理过程" class="header-anchor">#</a> 外中断处理过程</h3> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026081308106.png" alt="image-20221026081308106"></p> <h1 id="七、系统调用"><a href="#七、系统调用" class="header-anchor">#</a> 七、系统调用</h1> <p><code>系统调用</code>是操作系统提供给应用程序（程序员）使用的接口，可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026083536572.png" alt="image-20221026083536572"></p> <p>0</p> <h1 id="八、进程"><a href="#八、进程" class="header-anchor">#</a> 八、进程</h1> <p><code>程序段、数据段、PCB(进程控制块)</code>组成了<code>进程实体</code>。创建进程就是创建进程实体中的PCB，撤销进程就是撤销进程实体中的PCB。</p> <blockquote><p>PCB是进程存在的唯一标志</p></blockquote> <p><code>进程</code>是进程实体的==运行过程==，是系统进行资源分配和调度的一个独立单位</p> <h2 id="_1-进程的组成"><a href="#_1-进程的组成" class="header-anchor">#</a> 1. 进程的组成</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026101014079.png" alt="image-20221026101014079"></p> <p>​	<img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026101206693.png" alt="image-20221026101206693"></p> <h2 id="_2-进程的组织"><a href="#_2-进程的组织" class="header-anchor">#</a> 2. 进程的组织</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026102208884.png" alt="image-20221026102208884"></p> <h2 id="_3-进程的特征"><a href="#_3-进程的特征" class="header-anchor">#</a> 3.进程的特征</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026102632508.png" alt="image-20221026102632508"></p> <h1 id="九、进程的状态与转换"><a href="#九、进程的状态与转换" class="header-anchor">#</a> 九、进程的状态与转换</h1> <h2 id="_1-进程的状态"><a href="#_1-进程的状态" class="header-anchor">#</a> 1. 进程的状态</h2> <p>三种基本状态</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026104622917.png" alt="image-20221026104622917"></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026105335263.png" alt="image-20221026105335263"></p> <h2 id="_2-进程的转换"><a href="#_2-进程的转换" class="header-anchor">#</a> 2.进程的转换</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026105932540.png" alt="image-20221026105932540"></p> <h1 id="十、进程控制"><a href="#十、进程控制" class="header-anchor">#</a> 十、进程控制</h1> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026153713454.png" alt="image-20221026153713454"></p> <blockquote><p>使用<code>原语</code>实现进程控制。原语的特点就是执行期间<code>不允许中断</code>，这种操作即为<code>原子操作</code></p> <p>原语采用<code>关中断指令</code>和<code>开中断指令</code></p></blockquote> <p>原语执行在核心态</p> <h2 id="_1-原语"><a href="#_1-原语" class="header-anchor">#</a> 1.原语</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026154638732.png" alt="image-20221026154638732"></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026154714560.png" alt="image-20221026154714560"></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026155212334.png" alt="image-20221026155212334"></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026155430078.png" alt="image-20221026155430078"></p> <h1 id="十一、进程通信"><a href="#十一、进程通信" class="header-anchor">#</a> 十一、进程通信</h1> <p>进程通信就是指，进程之间的信息交换</p> <p>为了保证安全：<code>一个进程不能直接访问另一个进程的地址空间</code></p> <p>但是进程通信又是必须的，操作系统提供了一些方法：</p> <ol><li>共享存储</li> <li>消息传递</li> <li>管道通信</li></ol> <h2 id="_1-共享存储"><a href="#_1-共享存储" class="header-anchor">#</a> 1.共享存储</h2> <p>两个进程对共享空间的访问必须是互斥的</p> <p><code>基于数据结构的共享</code>：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢，限制多，是一种低级通信方式</p> <p><code>基于存储区的共享</code>：在内存中划分一块共享存储区，数组的形式、存放位置，都是由进程控制，而不是操作系统，相比之下，这种共享方式速度更快，是一种<code>高级通信</code>方式</p> <h2 id="_2-管道通信"><a href="#_2-管道通信" class="header-anchor">#</a> 2.管道通信</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026170138966.png" alt="image-20221026170138966"></p> <ol><li>管道只能采用<code>半双工通信</code>，某一时刻只能单向传输，如果想要双向传输，则需要设置两个管道。</li> <li>各进程要<code>互斥</code>地访问管道</li> <li>数据以字符流的形式写入管道，当管道写满时，write()写进程将被阻塞。当管道变空时，此读进程read()将被阻塞</li> <li>如果没写满，就不允许读。如果没读完，就不允许写</li> <li>数据一旦被读出，就会消失，所以读进程只能有一个。</li></ol> <h2 id="_3-消息传递"><a href="#_3-消息传递" class="header-anchor">#</a> 3. 消息传递</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026171254351.png" alt="image-20221026171254351"></p> <h1 id="十二、线程-多线程"><a href="#十二、线程-多线程" class="header-anchor">#</a> 十二、线程/多线程</h1> <h2 id="_1-什么是线程"><a href="#_1-什么是线程" class="header-anchor">#</a> 1. 什么是线程</h2> <p>传统的进程是程序的执行的最小单位，引入了线程之后，线程是最小的单位，一个进程可以有多个线程</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026172128359.png" alt="image-20221026172128359"></p> <p>线程就是<code>轻量级</code>进程。</p> <p>进程之间可以并发，进程中的线程也可以并发，进一步提高系统的并发度。使得一个进程内可以处理各种任务。</p> <p>引入线程之后，<code>进程</code>只作为<code>除CPU以外的系统资源的分配单元</code>，如打印机，内存地址，都是分配给进程的</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026172539697.png" alt="image-20221026172539697"></p> <h2 id="_2-线程的属性"><a href="#_2-线程的属性" class="header-anchor">#</a> 2.线程的属性</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026173415914.png" alt="image-20221026173415914"></p> <h2 id="_3-线程的实现方式"><a href="#_3-线程的实现方式" class="header-anchor">#</a> 3.线程的实现方式</h2> <ol><li>用户级线程</li></ol> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026183005921.png" alt="image-20221026183005921"></p> <ol start="2"><li>内核级线程</li></ol> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026183101346.png" alt="image-20221026183101346"></p> <ol start="3"><li>结合使用</li></ol> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026183225489.png" alt="image-20221026183225489"></p> <h2 id="_4-多线程"><a href="#_4-多线程" class="header-anchor">#</a> 4.多线程</h2> <p><code>多对一模型：</code></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026183455107.png" alt="image-20221026183455107"></p> <p><code>一对一模型：</code></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026183603681.png" alt="image-20221026183603681"></p> <p><code>多对多模型：</code></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221026183702219.png" alt="image-20221026183702219"></p> <h1 id="十三、处理机调度"><a href="#十三、处理机调度" class="header-anchor">#</a> 十三、处理机调度</h1> <h2 id="_1-调度概念"><a href="#_1-调度概念" class="header-anchor">#</a> 1. 调度概念</h2> <p>当有一堆任务要处理时，但由于资源有限，没法同时处理，就需要确定某种<code>规则</code>来<code>决定</code>处理这些任务的顺序，这就是调度所研究的问题</p> <h2 id="_2-三个层次"><a href="#_2-三个层次" class="header-anchor">#</a> 2. 三个层次</h2> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221027103236067.png" alt="image-20221027103236067"></p> <h2 id="_3-进程调度时机"><a href="#_3-进程调度时机" class="header-anchor">#</a> 3. 进程调度时机</h2> <p><code>进程调度</code>（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机</p> <p><strong><code>需要进行</code>进程调度与切换的情况：</strong></p> <ol><li>当前运行的进程<code>主动放弃</code>处理机：
<ol><li>进程正常终止</li> <li>运行中发生异常</li> <li>进程主动请求阻塞</li></ol></li> <li>当前运行的进程<code>被动放弃</code>处理机：
<ol><li>进程的时间片用完</li> <li>有紧急事件处理</li> <li>有更高优先级进程进入就绪队列</li></ol></li></ol> <p><strong><code>不能进行</code>进程调度与切换的情况：</strong></p> <ol><li>在<code>处理中断的过程中</code>。中断处理复杂，很难做到中断处理过程中进行进程切换</li> <li>进程在<code>操作系统内核程序临界区中</code>。</li> <li>在<code>原语操作过程中</code>。原子操作不可中断</li></ol> <blockquote><p><code>临界资源：</code>一个时间段内只允许一个进程使用的资源。各进程需要互斥访问临界资源</p> <p><code>临界区：</code>访问临界资源的那一段代码</p></blockquote> <p><code>内核程序临界区</code>：一般是用来访问<code>某种内核数据结构</code>的，比如进程的就绪队列</p> <p>当进程要进入就绪队列时，会对就绪队列上锁，等代码执行完成之后，再解锁，此时不能进行调度与切换。此时就绪队列时内核程序临界资源</p> <p>但是当进程要进入如打印机类的临界资源，也会上锁，但是也可以进行调度和切换。</p> <h2 id="_4-进程调度的方式"><a href="#_4-进程调度的方式" class="header-anchor">#</a> 4. 进程调度的方式</h2> <p><strong><code>非剥夺调度方式</code></strong></p> <p>又称<code>非抢占方式</code>，即只允许进程主动放弃处理机。即是有更紧急的进程，也依然会使用处理结果。</p> <p>实现简单，系统开销小，但无法处理紧急任务</p> <p><strong><code>剥夺调度方式</code></strong></p> <p>又称<code>抢占方式</code>，当一个进程正在使用处理机，如果有更紧急的进程，则立即暂停正在执行的进程，将处理机分配给更紧急的进程</p> <p>可以优先处理更紧急的进程，也可以让进程按照时间片轮流执行。适合于分时操作需提供，实时操作系统</p> <h2 id="_5-进程切换与过程"><a href="#_5-进程切换与过程" class="header-anchor">#</a> 5. 进程切换与过程</h2> <p><code>进程调度</code>：指的就是从就绪队列中选中一个要运行的进程，</p> <p><code>进程切换</code>：是指一个进程让出处理机，由另一个进程占用处理机的过程</p> <p>这个过程主要完成了：</p> <ol><li>对原来运行进程各种数据的保存</li> <li>对新的进程各种数据的恢复</li></ol> <h2 id="_6-调度算法指标"><a href="#_6-调度算法指标" class="header-anchor">#</a> 6. 调度算法指标</h2> <h3 id="_1-cpu利用率"><a href="#_1-cpu利用率" class="header-anchor">#</a> 1. CPU利用率</h3> <p><code>CPU利用率</code>：指CPU“忙碌”的时间占比总时间比例</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221027110623621.png" alt="image-20221027110623621"></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221027110738925.png" alt="image-20221027110738925"></p> <h3 id="_2-系统吞吐量"><a href="#_2-系统吞吐量" class="header-anchor">#</a> 2. 系统吞吐量</h3> <p>单位时间完成作业的数量</p> <p><code>系统吞吐量=总完成作业/总花费时间</code></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221027110932387.png" alt="image-20221027110932387"></p> <h3 id="_3-周转时间"><a href="#_3-周转时间" class="header-anchor">#</a> 3. 周转时间</h3> <p>是指从<code>作业被提交给系统开始，到作业完成为止</code>的这段时间间隔</p> <p><code>周转时间</code>=作业完成时间 - 作业提交时间</p> <p><code>平均周转时间=</code>各作业周转时间之和 / 作业数</p> <p><code>带权周转时间=</code>作业周转时间  /  作业实际运行的时间	= 	作业完成时间 - 作业提交时间 / 作业实际运行时间</p> <p><code>平均带权周转事件=</code>各作业带权周转时间之和 / 作业数</p> <h3 id="_4-等待时间"><a href="#_4-等待时间" class="header-anchor">#</a> 4.等待时间</h3> <p>是指进程或作业<code>处于等待处理机状态时间之和</code>，等待时间越长，满意度越低</p> <h3 id="_5-响应时间"><a href="#_5-响应时间" class="header-anchor">#</a> 5.响应时间</h3> <p>是指用户<code>提交请求</code>到<code>首次产生响应</code>所用的时间</p> <h1 id="十四、调度算法"><a href="#十四、调度算法" class="header-anchor">#</a> 十四、调度算法</h1> <p>后三种适合于<code>交互式系统</code></p> <h2 id="_1-fcfs"><a href="#_1-fcfs" class="header-anchor">#</a> 1. FCFS</h2> <blockquote><p><strong>先来先服务FCFS</strong></p></blockquote> <p><code>算法思想：</code>主要从公平角度思考，类似排队买东西</p> <p><code>算法规则：</code>按照作业/进程到达的先后顺序进行服务</p> <p><code>用于作业/进程调度</code>：用于作业调度时：考虑哪个作业先到达后备队列。用于进程调度时：考虑哪个进程先到达就绪队列</p> <p><code>是否可抢占</code>：非抢占式算法</p> <p><code>优缺点：</code>优点：公平，算法实现简单</p> <p>​					 缺点：对短作业不利，排在长作业之后，需要等待很长时间</p> <p><code>是否会导致饥饿：</code>不会</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221027113930687.png" alt="image-20221027113930687"></p> <h2 id="_2-sjf"><a href="#_2-sjf" class="header-anchor">#</a> 2. SJF</h2> <blockquote><p>短作业优先SJF</p></blockquote> <p><code>算法思想：</code>追求最少的平均等待时间，最少的平均</p> <p><code>算法规则：</code>最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p> <p><code>用于作业/进程调度：</code>两个都可使用，用于进程调度时称为：“短进程优先算法SPF”</p> <p><code>是否可抢占：</code>SJF和SPF是<code>非抢占式</code>，但也有抢占版本：<code>最短剩余时间优先算法SRTN</code></p> <p><code>优缺点</code>：优点：最短的平均等待时间。缺点：对短作业有利，对长作业不利</p> <p><code>是否会导致饥饿</code>：会</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221028095109173.png" alt="image-20221028095109173"></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221028095806460.png" alt="image-20221028095806460"></p> <h2 id="_3-hrrn"><a href="#_3-hrrn" class="header-anchor">#</a> 3. HRRN</h2> <blockquote><p><strong>高响应比优先算法</strong></p></blockquote> <p><code>算法思想：</code>要综合考虑作业/进程的等待时间和要求服务的时间</p> <p><code>算法规则：</code>每次调度之前计算各个作业/进程的<code>响应比</code>。选择响应比最高的作业/进程为其服务</p> <p>​					    <code>响应比=</code>等待时间+要求服务时间 / 要求服务时间</p> <p><code>用于作业/进程调度：</code>都可</p> <p><code>是否抢占式：</code>非抢占式</p> <p><code>优缺点：</code>综合考虑了等待时间和要求服务时间</p> <p><code>是否会饥饿：</code>不会</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221028102950354.png" alt="image-20221028102950354"></p> <h2 id="_4-rr"><a href="#_4-rr" class="header-anchor">#</a> 4.RR</h2> <p>以下三种适合<code>交互式系统</code></p> <blockquote><p><strong>时间片轮转算法</strong></p></blockquote> <p><code>算法思想：</code>公平的，轮流的，为各个进程提供服务，让每个进程在一定时间间隔内都可以得到响应</p> <p><code>算法规则：</code>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，若进程未在一个时间片内完成，则失去处理机，放到队尾重新排队</p> <p><code>用于作业/进程调度：</code>进程调度。只有作业放入进程之后，才可能被分配到时间片</p> <p><code>是否抢占式：</code>是抢占式。由时钟装置发出时钟中断通知CPU时间片已到</p> <p><code>优缺点：</code>公平，响应快，适用于分时操作系统。缺点：开销大，不区分任务的紧急程度</p> <p><code>是否会饥饿：</code>不会</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221028104735954.png" alt="image-20221028104735954"></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221028105143140.png" alt="image-20221028105143140"></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221028105106093.png" alt="image-20221028105106093"></p> <p><code>时间片</code>不能太大，太大就会变为<code>先来先服务</code>算法，会增大进程响应时间</p> <h2 id="_5-优先级调度算法"><a href="#_5-优先级调度算法" class="header-anchor">#</a> 5. 优先级调度算法</h2> <p><code>算法思想：</code>根据任务的紧急程度来决定处理顺序</p> <p><code>算法规则：</code>每个作业/进程都有各自的优先级，调度时选择优先级最高的</p> <p><code>用于作业/进程调度：</code>都可使用，还可以使用在IO调度中</p> <p><code>是否抢占式：</code>抢占式，非抢占式都有。</p> <p><code>优缺点：</code>区分紧急程度，重要程度。缺点：如果有很多高优先级进程，则可能导致饥饿</p> <p><code>是否会饥饿：</code>会</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221029180129648.png" alt="image-20221029180129648"></p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221029181010828.png" alt="image-20221029181010828"></p> <h2 id="_6-多级反馈队列调度"><a href="#_6-多级反馈队列调度" class="header-anchor">#</a> 6. 多级反馈队列调度</h2> <p><code>算法思想：</code>对上述其他算法进行折中权衡</p> <p><code>算法规则：</code>1.设置多级就绪队列，各级优先队列优先级从高到低，时间片从小到大。2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片</p> <p><code>用于作业/进程调度：</code>用于进程调度</p> <p><code>是否抢占：</code>抢占式算法。在k级队列中进程运行过程中，若更上级的队列中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p> <p><code>优缺点：</code>对各类型进程相对公平（FCFS优点）；每个新进程都可以很快得到响应（RR优点）；短进程只用较少的事件即可完成（SJF优点）；可灵活地调整各类进程的偏好程度</p> <p><code>是否导致饥饿</code>：会</p> <p><img src="http://www.erickiku.xyz/typora-images%5Cimage-20221029191652803.png" alt="image-20221029191652803"></p> <h1 id="十五、进程同步-互斥"><a href="#十五、进程同步-互斥" class="header-anchor">#</a> 十五、进程同步/互斥</h1> <h2 id="_1-进程同步"><a href="#_1-进程同步" class="header-anchor">#</a> 1.进程同步</h2> <p>并发具有异步性，有时需要同步处理这些异步问题。</p> <p>各进程之间推进需要一定的顺序。</p> <h2 id="_2-进程互斥"><a href="#_2-进程互斥" class="header-anchor">#</a> 2.进程互斥</h2> <p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要以下原则：</p> <ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的程序立即进入临界区</li> <li>忙则等待。当已有进程进入临界区，其他试图进入临界区的进程必须等待</li> <li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区</li> <li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ol> <h2 id="_3-进程互斥的软件实现"><a href="#_3-进程互斥的软件实现" class="header-anchor">#</a> 3.进程互斥的软件实现</h2> <h3 id="_1-单标签法"><a href="#_1-单标签法" class="header-anchor">#</a> 1. 单标签法</h3> <p><code>算法思想：</code>两个进程在使用完临界区之后，会把临界区 的使用权限交给另一个进程，也就是每个进程进入临界区的权限只能被另一个进程赋予</p> <p><img src="/assets/img/image-20221030112509598.a5ee37dd.png" alt="image-20221030112509598"></p> <h3 id="_2-双标志检查法"><a href="#_2-双标志检查法" class="header-anchor">#</a> 2. 双标志检查法</h3> <p><img src="/assets/img/image-20221030114240298.a94818a5.png" alt="image-20221030114240298"></p> <h3 id="_3-双标志后检查法"><a href="#_3-双标志后检查法" class="header-anchor">#</a> 3.双标志后检查法</h3> <p><img src="/assets/img/image-20221030114407558.9bc70720.png" alt="image-20221030114407558"></p> <h3 id="_4-peterson算法"><a href="#_4-peterson算法" class="header-anchor">#</a> 4.Peterson算法</h3> <p><img src="/assets/img/image-20221030114927003.d5c9771b.png" alt="image-20221030114927003"></p> <p>Peterson算法用软件解决了进程互斥问题，遵循了<code>空闲让进，忙则等待，有限等待 三个原则。</code>但是没有遵循<code>让权等待</code></p> <h2 id="_4-进程互斥的硬件实现"><a href="#_4-进程互斥的硬件实现" class="header-anchor">#</a> 4.进程互斥的硬件实现</h2> <h3 id="_1-中断屏蔽方法"><a href="#_1-中断屏蔽方法" class="header-anchor">#</a> 1. 中断屏蔽方法</h3> <p><img src="/assets/img/image-20221030163311867.67e8c564.png" alt="image-20221030163311867"></p> <h3 id="_2-testandset指令"><a href="#_2-testandset指令" class="header-anchor">#</a> 2.TestAndSet指令</h3> <p><img src="/assets/img/image-20221030164305503.84d2763a.png" alt="image-20221030164305503"></p> <h3 id="_3-swap指令"><a href="#_3-swap指令" class="header-anchor">#</a> 3.Swap指令</h3> <p><img src="/assets/img/image-20221030164618214.bc42c720.png" alt="image-20221030164618214"></p> <h1 id="十六、信号量机制"><a href="#十六、信号量机制" class="header-anchor">#</a> 十六、信号量机制</h1> <p>用户进程可以通过使用操作系统提供的<code>一对原语</code>来对<code>信号量</code>进行操作，从而很方便的实现了进程互斥、进程同步</p> <p><code>信号量</code>其实就是一个变量，可以用<code>一个信号量表示系统中某种资源的数量</code></p> <p><code>一对原语：wait(S)</code>原语和<code>signal(S)</code>原语，可以把原语理解为自己写的函数，函数名为wait和signal，括号里的<code>信号量S</code>其实就是函数调用时传入的一个参数。</p> <p><code>wait、signal</code>原语常简称为<code>P、V操作</code>。因此，做题时常把wait(S和signal(S)两个操作写为<code>P(S)、V(S)</code></p> <h2 id="_1-整形信号量"><a href="#_1-整形信号量" class="header-anchor">#</a> 1. 整形信号量</h2> <p><img src="/assets/img/image-20221030184919026.df6638b9.png" alt="image-20221030184919026"></p> <h2 id="_2-记录型信号量"><a href="#_2-记录型信号量" class="header-anchor">#</a> 2. 记录型信号量</h2> <p><img src="/assets/img/image-20221030191334035.1884c3a1.png" alt="image-20221030191334035"></p> <h2 id="_3-信号量机制实现进程互斥"><a href="#_3-信号量机制实现进程互斥" class="header-anchor">#</a> 3. 信号量机制实现进程互斥</h2> <p><img src="/assets/img/image-20221030192021395.c23a6aec.png" alt="image-20221030192021395"></p> <h2 id="_4-信号量机制实现进程同步"><a href="#_4-信号量机制实现进程同步" class="header-anchor">#</a> 4. 信号量机制实现进程同步</h2> <p><img src="/assets/img/image-20221030201007592.9e8c5e0c.png" alt="image-20221030201007592"></p> <h2 id="_5-实现进程的同步关系"><a href="#_5-实现进程的同步关系" class="header-anchor">#</a> 5.实现进程的同步关系</h2> <p><img src="/assets/img/image-20221030201357910.db752ec7.png" alt="image-20221030201357910"></p> <h1 id="十七、生产者消费者"><a href="#十七、生产者消费者" class="header-anchor">#</a> 十七、生产者消费者</h1> <p>系统中有一组生产者进程和消费者进程，生产者进程每次生产一个数据放入缓存区，消费者进程每次从缓冲区中取出一个数据并使用</p> <p>生产者、消费者共享一个初始为空、大小为n的缓冲区</p> <p>只有缓冲区没满时，生产者才能把数据放入缓冲区，否则必须等待。只有缓冲区不空时，消费者才能从中取出产品，否则必须等待</p> <p>缓冲区是<code>临界资源</code>，各进程必须互斥的访问</p> <p><img src="/assets/img/image-20221030202940683.d47aa0f5.png" alt="image-20221030202940683"></p> <h2 id="_1-多生产者多消费者"><a href="#_1-多生产者多消费者" class="header-anchor">#</a> 1. 多生产者多消费者</h2> <p><img src="/assets/img/image-20221031091429087.04875196.png" alt="image-20221031091429087"></p> <p><img src="/assets/img/image-20221031091501823.c57601c0.png" alt="image-20221031091501823"></p> <p>如果缓冲区大小大于1，就必须专门放置一个互斥信号量mutex来保证互斥访问缓冲区</p> <h1 id="十八、吸烟者问题"><a href="#十八、吸烟者问题" class="header-anchor">#</a> 十八、吸烟者问题</h1> <p><img src="/assets/img/image-20221031092527012.a93fa703.png" alt="image-20221031092527012"></p> <p>如何实现进程同步和进程互斥</p> <p><img src="/assets/img/image-20221031093300160.67a260ad.png" alt="image-20221031093300160"></p> <h1 id="十九、读者、写者"><a href="#十九、读者、写者" class="header-anchor">#</a> 十九、读者、写者</h1> <p><img src="/assets/img/image-20221031093738934.07de4314.png" alt="image-20221031093738934"></p> <p><img src="/assets/img/image-20221031094938348.79d5d4b0.png" alt="image-20221031094938348"></p> <p><img src="/assets/img/image-20221031095025917.71c9dde2.png" alt="image-20221031095025917"></p> <h1 id="二十、哲学家进餐问题"><a href="#二十、哲学家进餐问题" class="header-anchor">#</a> 二十、哲学家进餐问题</h1> <p><img src="/assets/img/image-20221031095631870.589fc1ea.png" alt="image-20221031095631870"></p> <p>==这个方法不可取==</p> <p>解决进程死锁</p> <p><img src="/assets/img/image-20221031100721047.ce220037.png" alt="image-20221031100721047"></p> <h1 id="二十一、管程"><a href="#二十一、管程" class="header-anchor">#</a> 二十一、管程</h1> <p>为了解决PV操作的复杂，使用管程来简化这些操作</p> <h2 id="_1-管程解决生产者消费者问题"><a href="#_1-管程解决生产者消费者问题" class="header-anchor">#</a> 1.管程解决生产者消费者问题</h2> <p><img src="/assets/img/image-20221031102027887.fb0cff5b.png" alt="image-20221031102027887"></p> <p><img src="/assets/img/image-20221031102327873.9581cdc6.png" alt="image-20221031102327873"></p> <p><img src="/assets/img/image-20221031102511010.27417b3b.png" alt="image-20221031102511010"></p> <h1 id="二十二、死锁"><a href="#二十二、死锁" class="header-anchor">#</a> 二十二、死锁</h1> <h2 id="_1-死锁、饥饿、死循环"><a href="#_1-死锁、饥饿、死循环" class="header-anchor">#</a> 1.死锁、饥饿、死循环</h2> <p><code>死锁：</code>各进程互相等待对方手里的资源，导致各进程互相阻塞，无法向前推进的现象</p> <p><code>饥饿：</code>长期得不到想要的资源，某进程无法向前推进的现象，。</p> <p><code>死循环：</code>跳不出某个循环，有时是bug导致，有时是故意设置</p> <h2 id="_2-死锁发生的条件"><a href="#_2-死锁发生的条件" class="header-anchor">#</a> 2.死锁发生的条件</h2> <p>必须满足以下四个条件：</p> <p><code>互斥条件：</code>只有对必须互斥使用的资源的争抢才会导致死锁</p> <p><code>不剥夺条件：</code>进程所获得的资源在未使用完之前，不能 由其他进程夺走资源，只能主动释放</p> <p><code>请求和保持条件：</code>进程已经保持了一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又不释放自己的资源</p> <p><code>循环等待条件：</code>链中的每一个进程已获得的资源同时被下一个进程所请求</p> <p><code>注意：</code>发生死锁时一定有循环等待，但是发生循环等待时未必死锁</p> <h2 id="_3-死锁的处理策略"><a href="#_3-死锁的处理策略" class="header-anchor">#</a> 3.死锁的处理策略</h2> <ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个</li> <li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li> <li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li></ol> <h2 id="_4-预防死锁"><a href="#_4-预防死锁" class="header-anchor">#</a> 4.预防死锁</h2> <h3 id="_1-破坏互斥条件"><a href="#_1-破坏互斥条件" class="header-anchor">#</a> 1.破坏互斥条件</h3> <p>把互斥的资源改为允许共享使用的资源。如<code>SPOOLing技术</code></p> <p>缺点：不是所有的资源都可以改造成可共享使用的资源</p> <h3 id="_2-破坏不剥夺条件"><a href="#_2-破坏不剥夺条件" class="header-anchor">#</a> 2.破坏不剥夺条件</h3> <ol><li>当某个进程请求新的资源得不到时，必须立刻释放已拥有的资源，等待再重新申请。也就是说，即是某些资源尚未使用完，也要主动释放。</li> <li>当某个进程需要的资源被其他进程占用时，可以由操作系统协助，将想要的资源强行剥夺。</li></ol> <p>缺点：实现复杂。释放资源可能导致前一段工作失效</p> <h3 id="_3-破坏请求和保持条件"><a href="#_3-破坏请求和保持条件" class="header-anchor">#</a> 3.破坏请求和保持条件</h3> <p>可以采用静态分配方法，即进程在运行前，申请完它所需要的全部资源，在资源未完成之前，不让进程运行</p> <p>缺点：资源利用率低，可能导致饥饿</p> <h3 id="_4-破坏循环等待条件"><a href="#_4-破坏循环等待条件" class="header-anchor">#</a> 4.破坏循环等待条件</h3> <p>可采用<code>顺序资源分配法</code>。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源。</p> <p>一个进程只有已占有小编号的资源时，才有资格申请大编号的资源。</p> <p>缺点：不方便增加新的设备，需要重新分配所有的编号。进程实际使用资源的顺序可能和序号递增顺序不一致，会导致资源浪费。必须按规定次序申请资源，用户编程麻烦</p> <h2 id="_5-避免死锁"><a href="#_5-避免死锁" class="header-anchor">#</a> 5.避免死锁</h2> <h3 id="_1-什么是安全序列"><a href="#_1-什么是安全序列" class="header-anchor">#</a> 1. 什么是安全序列</h3> <p><code>安全序列：</code>就是指如果系统按照一种序列分配资源，则每个进程都能顺利完成。只要找到一个安全序列，系统就是<code>安全状态</code>。安全序列可以有多个。</p> <p>如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了<code>不安全状态</code>。</p> <p>如果系统处于<code>安全状态</code>，就<code>一定不发发生死锁</code>，如果系统进入<code>不安全状态</code>，就<code>可能发生死锁</code>。</p> <p>但发生死锁时，一定是在不安全状态下。</p> <p><code>银行家算法：</code>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。</p> <h3 id="_2-银行家算法"><a href="#_2-银行家算法" class="header-anchor">#</a> 2.银行家算法</h3> <p><img src="/assets/img/image-20221031164939094.3afeb2ed.png" alt="image-20221031164939094"></p> <p><img src="/assets/img/image-20221031165025486.96c16d7c.png" alt="image-20221031165025486"></p> <h2 id="_6-死锁的检测和解除"><a href="#_6-死锁的检测和解除" class="header-anchor">#</a> 6.死锁的检测和解除</h2> <h3 id="_1-死锁的检测"><a href="#_1-死锁的检测" class="header-anchor">#</a> 1.死锁的检测</h3> <p>为了能对系统是否已经发生了死锁进行检测：</p> <ol><li>用<code>某种数据结构</code>来保存资源的请求和分配信息。</li> <li>提供<code>一种算法</code>，利用上述信息来检测系统是否已经进入死锁状态</li></ol> <p><img src="/assets/img/image-20221031170701813.d10ae6ab.png" alt="image-20221031170701813"></p> <p>如果系统中剩余的可用资源数足够<code>满足进程的需求</code>，那么这个进程暂时是不会阻塞的，可以顺利地执行下去，如果这个进程执行结束了，把资源归还给系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去</p> <p><img src="/assets/img/image-20221031174044568.50bc69e3.png" alt="image-20221031174044568"></p> <p>如果不能消除<code>所有边</code>，那么就是发生了死锁。上面的图就是一个死锁</p> <p>检测死锁的算法：</p> <ol><li>在资源分配图中，找出既不阻塞又不是孤点的进程Pi，就是可以消掉边的点，消去它的请求边和分配边，使之成为孤立的节点。在上图不是死锁的图中，P1满足，把P1的边消掉</li> <li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程变为非阻塞进程。</li> <li>如果消去所有的边，则称该图是<code>可完全简化的</code></li></ol> <p><code>死锁定理：</code>如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</p> <h3 id="_2-解除死锁"><a href="#_2-解除死锁" class="header-anchor">#</a> 2.解除死锁</h3> <ol><li><code>资源剥夺法。</code>挂起某些死锁进程，暂时放在外存，并剥夺它的资源，将这些资源分配给其他的死锁进程。</li> <li><code>撤销进程法。</code>强制撤销部分进程，甚至全部进程。并剥夺这些进程的资源。实现简单，代价大，会让已经快结束的进程功亏一篑</li> <li><code>进程回退法。</code>让一个或多个进程回退到足以避免死锁的地步，这就要求系统要记录进程的历史信息，设置还原点</li></ol> <h1 id="二十三、内存"><a href="#二十三、内存" class="header-anchor">#</a> 二十三、内存</h1> <blockquote><p>操作系统是系统资源的管理者，当然也需要对内存进行管理，需要管理的有：</p> <ol><li>负责<code>内存空间的分配与回收</code></li> <li>提供从逻辑上<code>对内存空间进行扩充</code></li> <li>提供<code>地址转换功能</code>，负责程序的逻辑地址与物理地址的转换</li> <li>提供<code>内存保护</code>功能，保证各进程在各自存储空间内运行，互不干扰</li></ol></blockquote> <p>在内存中编译时，只关心<code>相对位置</code>，实际放入内存时，再想办法根据起始位置得到<code>绝对地址</code></p> <p><code>相对地址</code>又称<code>逻辑地址</code>，<code>绝对地址</code>又称<code>物理地址</code></p> <p><img src="/assets/img/image-20221031193032345.a2d9e961.png" alt="image-20221031193032345"></p> <h2 id="_1-装入方式"><a href="#_1-装入方式" class="header-anchor">#</a> 1.装入方式</h2> <p>装入的三种方式（用三种不同的方法完成<code>逻辑地址 到 物理地址 的转换</code>）：</p> <ol><li>绝对装入
在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存</li> <li>静态重定位
<img src="/assets/img/image-20221031192754718.e2961410.png" alt="image-20221031192754718"></li> <li>动态重定位
<img src="/assets/img/image-20221031192929747.81f7fd93.png" alt="image-20221031192929747"></li></ol> <h2 id="_2-链接方式"><a href="#_2-链接方式" class="header-anchor">#</a> 2.链接方式</h2> <p><img src="/assets/img/image-20221031193340739.42b3a279.png" alt="image-20221031193340739"></p> <h2 id="_3-内存保护"><a href="#_3-内存保护" class="header-anchor">#</a> 3.内存保护</h2> <p><img src="/assets/img/image-20221031195146659.68da8679.png" alt="image-20221031195146659"></p> <p><img src="/assets/img/image-20221031195256953.c6c99263.png" alt="image-20221031195256953"></p> <h2 id="_4-覆盖与交换"><a href="#_4-覆盖与交换" class="header-anchor">#</a> 4.覆盖与交换</h2> <p>计算机内存较小，无法把一个大型软件全部运行</p> <p>之后引入<code>覆盖技术</code>，用来<code>解决“程序大小超过物理内存总和”</code>的问题</p> <p>覆盖技术思想：将<code>程序分为多个段</code>，常用的段常驻内存，不常用的段在需要时调入内存</p> <p>内存中分为一个<code>“固定区”</code>，和若干个<code>“覆盖区”</code></p> <p>需要常驻内存的段放在<code>固定区</code>，调入后就不再调出，除非运行结束</p> <p>不常用的段放在<code>“覆盖区”</code>，需要用时调入内存，用不到时调出内存</p> <p><img src="/assets/img/image-20221031201127995.aa62ca2d.png" alt="image-20221031201127995"></p> <p><code>交换技术设计思想</code>：内存空间紧张时，系统将内存中某些进程暂时调出外存，把外存中某些已具备运行条件的进程换入内存</p> <p><img src="/assets/img/image-20221031202417496.d0fdd7be.png" alt="image-20221031202417496">
z
<img src="/assets/img/image-20221031202730509.935021da.png" alt="image-20221031202730509"></p> <p><img src="/assets/img/image-20221031203139203.d0984e6d.png" alt="image-20221031203139203"></p> <h2 id="_5-内存空间的分配与回收"><a href="#_5-内存空间的分配与回收" class="header-anchor">#</a> 5.内存空间的分配与回收</h2> <p><code>内部碎片：</code>分配个某进程的内存区域中，如果有些部分没有用上</p> <p><code>外部碎片：</code>是指内存中的某些空闲分区由于太小而难以利用</p> <h3 id="_1-连续分配管理方式"><a href="#_1-连续分配管理方式" class="header-anchor">#</a> （1）连续分配管理方式</h3> <p>为用户分配一段连续的内存空间</p> <blockquote><p><strong>单一连续分配</strong></p></blockquote> <p>在单一连续分配方式中，内存被分为<code>系统区</code>和<code>用户区</code>。系统区通常位于内存的低地址部分，用于存放操作系统相关数据。用户区用于存放用于进程相关数据。</p> <p>单一连续分配<code>只能有一道用户程序</code>，用户程序独占整个用户区空间。</p> <p>有点：实现简单，无外部碎片；可以采用覆盖技术扩充内存。不一定需要采取内存保护</p> <p>用于早期的计算机系统</p> <p>缺点：只能用于单用户，单任务的操作系统中，有<code>内部碎片</code>，存储器 利用率极低。</p> <p><code>内部碎片：</code>分配给某进程的内存区域中，有些部分没有用上，就是内部碎片</p> <p><img src="/assets/img/image-20221101111712854.c6cd82be.png" alt="image-20221101111712854"></p> <blockquote><p><strong>固定分区分配</strong></p></blockquote> <p>20世纪60年代，出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会互相干扰，于是将整个<code>用户空间</code>划分为<code>若干个固定大小的分区</code>，在<code>每个分区中只装入一道作业</code>。</p> <p><img src="/assets/img/image-20221101111834019.10f81b2d.png" alt="image-20221101111834019"></p> <p><img src="/assets/img/image-20221101111859551.f87d15ac.png" alt="image-20221101111859551"></p> <p>分区大小相等：缺乏灵活性，但是很<code>适合用于一台计算机控制多个相同对象的场合</code></p> <p>分区大小不等：增加了灵活性，可以满足不同大小的进程需求。</p> <p>操作系统需要建立一个数据结构&gt;<code>分区说明表</code>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列，每个表项包括对应分区的<code>大小、起始地址、状态</code>，</p> <p><img src="/assets/img/image-20221102090746058.7ebd8e8a.png" alt="image-20221102090746058"></p> <p>当用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的，未分配的分区，将分区分配给该程序，然后状态改为：已分配</p> <p>优点：实现简单，<code>无外部碎片</code></p> <p>缺点：1.程序太大时，需要采用覆盖技术，覆盖技术又会降低性能。2.会产生内部碎片，内存利用率低</p> <blockquote><p><strong>动态分区分配</strong></p></blockquote> <p>又称<code>可变分区分配</code>，这种分配方式，<code>不会预先划分内存区</code>，在程序装入内存时，根据<code>进程的大小动态的创建分区</code>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p> <p><img src="/assets/img/image-20221102091650516.77b95dfd.png" alt="image-20221102091650516"></p> <ol><li><p>系统要用什么样的数据结构记录内存的使用情况
两种数据结构：<code>空闲分区表</code>和<code>空闲分区链</code> <img src="/assets/img/image-20221102092150308.726f59ec.png" alt="image-20221102092150308"> <img src="/assets/img/image-20221102092242912.e9ec3d67.png" alt="image-20221102092242912"></p></li> <li><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配</p> <p><img src="/assets/img/image-20221102095610234.e6fb2b49.png" alt="image-20221102095610234"></p> <p>（1）首次适应算法
<code>算法思想：</code>每次都从低地址开始查找，找到第一个能满足大小的空闲分区
<code>实现方法：</code>空闲分区表以<code>地址递增的次序排列</code>，每次分配内存时，按顺序查找空闲分区链，找到第一个满足的空闲分区</p> <p>（2）最佳适应算法</p> <p>​	<code>算法思想：</code>为了在大进程来到的时候，有大片空闲分区，所以优先使用最小的空闲区</p> <p>​	<code>实现：</code>空闲分区表按<code>容量递增次序排列</code>，每次分配内存时，按顺序查找空闲分区表或链，找到的第一个空闲分区，就是最小的满足进程的分区</p> <p>（3）最坏适应算法</p> <p>又称<code>最大适应算法</code></p> <p>​	<code>算法思想：</code>为了解决最佳适应算法遗留的问题：留下太多难以利用的小碎片。在每次分配时优先使用最大的连续空闲区，这样留下的空闲分区不会太小</p> <p>​	<code>实现：</code>按<code>容量递减次序排序</code>，按顺序查找，找到大小满足的第一个空闲分区
​	<code>缺点：</code>没有给大进程留足够的空闲分区</p> <p>（4）邻近适应算法</p> <p>​	<code>算法思想：</code>每次查找都从上次查找结束的位置开始检索。解决了每次从链头查找的开销</p> <p>​	<code>实现：</code>空闲分区以<code>地址递增循环排列</code>，形成一个循环链表，每次分配内存时，从上次查找结束的位置开始查找空闲分区链，找到第一个能满足的空闲分区</p></li> <li><p>如何进行分区的分配和回收操作
<img src="/assets/img/image-20221102092616982.90196ae3.png" alt="image-20221102092616982">
(1)当有一个4MB的进程需要分配，有两种方式：
分给分区1：<img src="/assets/img/image-20221102092842674.9200d43a.png" alt="image-20221102092842674">
分给分区3：<img src="/assets/img/image-20221102092920450.b36854ee.png" alt="image-20221102092920450">
(2)当有程序执行完，需要回收：
情况1：进程4回收之后
<img src="/assets/img/image-20221102093258945.d8826278.png" alt="image-20221102093258945"> <img src="/assets/img/image-20221102093340707.50fd0e5b.png" alt="image-20221102093340707">
情况2：进程3回收之后
<img src="/assets/img/image-20221102093612368.b5fb5d2f.png" alt="image-20221102093612368">
情况3：进程4回收之后
<img src="/assets/img/image-20221102093750188.e5fc5b6d.png" alt="image-20221102093750188">
情况4：进程2回收之后
<img src="/assets/img/image-20221102093929988.b5b7b372.png" alt="image-20221102093929988"></p></li></ol> <h3 id="_2-非连续分配"><a href="#_2-非连续分配" class="header-anchor">#</a> （2）非连续分配</h3> <p>为用户进程分配的可以是一些离散的内存空间</p> <p>==由于太多，不适合在三级标题下记录，因此在此处使用一级标题来笔记<code>分页存储</code>==</p> <h1 id="二十四、分页存储"><a href="#二十四、分页存储" class="header-anchor">#</a> 二十四、分页存储</h1> <h2 id="_1-基本分页存储管理"><a href="#_1-基本分页存储管理" class="header-anchor">#</a> 1.基本分页存储管理</h2> <h3 id="_1-基本概念"><a href="#_1-基本概念" class="header-anchor">#</a> 1.基本概念</h3> <p>将内存空间分为一个个<code>大小相等的分区</code>，比如每个分区4kb，每个分区就是一个<code>页框</code>，也可以叫<code>页帧</code>、<code>内存块</code>、<code>物理块</code>。每个页框有一个编号，即<code>页框号</code>，又叫<code>内存块号</code>、<code>页帧号</code>、<code>物理块号</code>，<strong>页框号从0开始</strong></p> <p>将用户进程的地址空间也分为<code>与页框大小相等</code>的多个区域，称为<code>页</code>或<code>页面</code>。每个页面也有一个编号，即<code>页号</code>，也是<strong>从0开始</strong></p> <p>页框不能太大，否则会产生过大的内部碎片</p> <p>操作系统把一个进程分为的多个页面分配进内存空间，分别放入一个页框中，所以，<code>页面</code>与<code>页框</code>有个<code>一一对应</code>的关系。</p> <p>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中</p> <h3 id="_2-地址转换"><a href="#_2-地址转换" class="header-anchor">#</a> 2.地址转换</h3> <p>分页存储的地址转换</p> <p><img src="/assets/img/image-20221102111036716.4f60611e.png" alt="image-20221102111036716"></p> <p><img src="/assets/img/image-20221102111440035.bc2816ee.png" alt="image-20221102111440035"></p> <p><img src="/assets/img/image-20221102175225458.9ecdf7e1.png" alt="image-20221102175225458"></p> <p><strong>逻辑地址结构</strong></p> <p><img src="/assets/img/image-20221102175402749.7721c51d.png" alt="image-20221102175402749"></p> <p>为了知道<code>页号</code>对应页面在内存中的地址，有如下页表</p> <p><img src="/assets/img/image-20221102175619073.92069fec.png" alt="image-20221102175619073"></p> <h3 id="_3-基本地址变换机构"><a href="#_3-基本地址变换机构" class="header-anchor">#</a> 3.基本地址变换机构</h3> <p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p> <p>通常会在系统中设置一个<code>页表寄存器（PTR）</code>，存放的是<code>页表在内存中的起始地址F</code>和<code>页表长度M</code>。</p> <p>进程未执行时，页表的F和M<code>存放在进程控制块（PCB）中</code>，当进程被调度时，操作系统内核会把它们放到页面寄存器中</p> <p>流程：</p> <p><img src="/assets/img/image-20221102181311637.c3a69dcb.png" alt="image-20221102181311637"></p> <p><img src="/assets/img/image-20221102181213999.ba4f84f4.png" alt="image-20221102181213999"></p> <p><strong>例题：</strong></p> <p><img src="/assets/img/image-20221102181604763.3844974d.png" alt="image-20221102181604763"></p> <h3 id="_4-具有快表的地址变换机构"><a href="#_4-具有快表的地址变换机构" class="header-anchor">#</a> 4.具有快表的地址变换机构</h3> <h4 id="局部性原理"><a href="#局部性原理" class="header-anchor">#</a> 局部性原理</h4> <p><img src="/assets/img/image-20221102183517198.84ae385e.png" alt="image-20221102183517198"></p> <h4 id="什么是快表"><a href="#什么是快表" class="header-anchor">#</a> 什么是快表</h4> <p><code>快表</code>，又称<code>联想寄存器（TLB）</code>，是一种<code>访问速度比内存快很多</code>的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为<code>慢表</code></p> <p>快表流程：</p> <p><img src="/assets/img/image-20221102184153075.576643d6.png" alt="image-20221102184153075"></p> <p><img src="/assets/img/image-20221102184033463.e29e435a.png" alt="image-20221102184033463"></p> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p><img src="/assets/img/image-20221102184254885.b3e641f6.png" alt="image-20221102184254885"></p> <h2 id="_2-两级页表"><a href="#_2-两级页表" class="header-anchor">#</a> 2.两级页表</h2> <p>单级页表存在的问题：</p> <p>问题1：页表必须连续存放，因此当页表很大时，需要占用多个连续的页框</p> <p>问题2：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</p> <h3 id="解决问题1"><a href="#解决问题1" class="header-anchor">#</a> 解决问题1</h3> <p>可将长页表进行分组，使每个内存块刚好可以放入一个分组。</p> <p>要为离散分配的页表再建立一张表，成为<code>页目录表</code>，或称<code>外层页表</code>、<code>顶层页表</code></p> <p>图示：</p> <p><img src="/assets/img/image-20221102195022772.dd2a7199.png" alt="image-20221102195022772"></p> <p><img src="/assets/img/image-20221102195354719.f41f50cb.png" alt="image-20221102195354719"></p> <p>如何实现地址转换：</p> <p><img src="/assets/img/image-20221102195606238.ad7af59e.png" alt="image-20221102195606238"> <img src="/assets/img/350.8b9d4a20.jpg" alt="image-20221102195606238"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontPro/webpack5模式.html" class="prev">
        Webpack5模式
      </a></span> <span class="next"><a href="/课程/日语.html">
        日语
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5555aa2a.js" defer></script><script src="/assets/js/3.dce90c24.js" defer></script><script src="/assets/js/2.5b478fa2.js" defer></script>
  </body>
</html>
